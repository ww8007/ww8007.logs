# 😆 2. OBJ 객체지향 프로그래밍



## 2. 객체지향 프로그래밍

### 위키

*   TEMPLATE METHOD 패턴

    부모 클래스에 기본적인 알고리즘의 흐름을 구현하고

    중간에 필요한 처리를 자식 클래스에게 위임
*   업캐스팅(upcasting)

    자식 클래스가 부모 클래스를 대신하는 것

    자식 클래스가 부모 클래스의 타입으로 변화되는 업캐스팅
*   다형성

    객체지향 프로그램의 컴파일 시간 의존성과 실행 시간 의존성이 다를 수 있다는 사실을 기반

    컴파일 시간 의존성 ↔  실행 시간 의존성을 다르게 만들 수 있는 객체지향의 특성을 이용

    → 서로 다른 메서드를 실행할 수 있게

    > 동일한 메시지를 수신했을 때 객체의 타입에 따라 다르게 응답할 수 있는 능력
    >
    > 다형적인 협력에 참여하는 객체들은 모두 같은 메시지를 이해할 수 있어야 함
    >
    > → 인터페이스가 동일해야 함

    💡 그럼 인터페이스가 어떻게 같게 하나요?

    > 이를 상속을 이용해서 구현

    *   다형성을 구현하는 방법은 매우 다양하지만

        메시지를 응답하기 위해 → 실행될 메서드를 컴파일 시점이 아닌

        → 실행 시점에 결정한다는 공통점이 있음

        → 다시 말해 메서드를 실행 시점에 바인딩 한다는 점
    * 이를 지연 바인딩, 동적 바인딩
    *   이에 반해 전통적인 함수 호출처럼 → 컴파일 시점에 실행될 함수나 프로시저를 결정하는 것을

        → 초기 바인딩, 정적 바인딩
    *   객체지향이 컴파일 시점의 의존성과 실행 시점의 의존성을 분리하고

        하나의 메시지를 선택적으로 서로 다른 메서드에 연결할 수 있는 이유가 바로

        지연 바인딩이라는 메커니즘을 사용하기 때문

    💡 클래스를 상속하는 것이 → 다형성을 구현할 수 있는 유일한 방법 자체는 아님 이는 추상적인 개념이며 → 이를 구현할 수 있는 방법 자체는 다양하다는 사실을 인지
*   구현 상속과 인터페이스 상속

    > 상속 : 구현 상속, 인터페이스 상속으로 구분이 가능함

    \-구현 상속 → 서브 클래싱(subclassing)

    * 인터페이스 상속 → 서브타이핑(subtyping)
      *   다형적인 협력을 위해 부모 클래스와 자식 클래스가 인터페이스를 공유할 수 있도록

          상속을 이용하는 것 → 인터페이스 상속

    상속은 구현 상속이 아닌 → 인터페이스 상속을 위해 사용해야 함

    > 대부분의 사람들은 상속을 코드 재사용의 목적이라고 하지만 이는 오해다

    인터페이스를 재사용 목적이 아닌 구현을 재사용할 목적으로 상속을 재사용하면 → 변경에 취약한 코드를 낳음
*   인터페이스

    구현에 대한 고려 없이 다형적인 협력에 참여하는 클래스들이

    공유 가능한 외부 인터페이스를 정의한 것

    C++ → 추상 기반 클래스(Abastract Base Class, ABC) → 자바의 인터페이스 구현 가능
*   추상화 이용의 장점

    💡 추상화 이용의 장점

    > 세부적인 내용을 무시한 채 상위 정책을 쉽고 간단하게 표현할 수 있음

    이런 특징은 세부사항에 억눌리지 않고 → 상위 개념만으로도 도메인의 중요한 개념을 설명할 수 있게 함

    > 추상화를 이용해 상위 정책을 기술 → 기본적인 애플리케이션의 협력 흐름을 기술한다는 것을 의미함

    > 재사용 가능한 설계의 기본을 이루는 디자인 패턴, 프레임워크 모두
    >
    > 추상화를 이용해 상위 정책을 정의하는 객체지향의 메커니즘을 활용하고 있기 때문

    > 두 번째 특징은 첫 번째 특징으로부터 유추 가능함
    >
    > 추상화를 이용해 상위 정책을 표현하면 기존의 구조를 수정하지 않고도 새로운 기능을 쉽게 추가, 확장 가능함
    >
    > 다시 말해 설계를 유연하게 만들 수 있음
*   합성

    다른 객체의 인스턴스를 자신의 인스턴스 변수로 포함해서 재사용하는 방법

## 영화 예매 시스템

### 요구사항 살펴보기

> 사용자는 영화 예매 시스템을 통해 빠르게 보고 싶은 영화를 예매

> 영화

* 영화에 관한 기본 정보를 표현
* 제목, 상영시간, 가격 정보 → 기본적인 정보들

> 상영

* 실제로 관객들이 영화를 관람하는 사건을 표현
* 상영 일자, 시간, 순번

❓ 왜 이렇게 구분하나요?

> 사용자가 실제로 예매하는 대상은
>
> 영화가 아닌 → 상영이기 때문임
>
> 영화를 예매한다고 표현하지만 → 실제로 특정 시간에 상영되는 영화를 관람할 수 있는 권리를 구매

#### 특수 조건

> 요금 할인

1. 할인 조건
2. 할인 정책

> 할인 조건

* 가격의 할인 여부를 결정함
* 순서 조건과 기간 조건의 두 종류로 나눌 수 있음
*   순서 조건

    상영 순번을 이용해 할인 여부를 결정하는 규칙

    순번이 10인 영화인 경우 매일 10번째로 상영되는 영화를 예매한 사용자들에게 할인 혜택
*   기간 조건

    영화, 상영 시작 시간을 이용해 할인 여부를 결정함

    기간 조건 : 요일, 시작 시간, 종료 시간

    영화 시작시간이 → 해당 기간 안에 포함될 경우 요금을 할인

    요일이 월요일, 시작시간이 오전 10시, 종료 시간이 오후 1시

    월요일 오전 10시 \~ 오후 1시 상영되는 모든 영화 할인
*   할인 정책

    할인 요금을 결정함
*   금액 할인 정책

    예매 요금에서 일정 금액을 할인해주는 방식
*   비율 할인 정책

    정가에서 일정 비율의 요금을 할인해 주는 방식
*   어떤 영화의 가격이 9000원 이고

    금액 할인 정책이 800원일 경우 → 예매 가격 8200원
* 10% 비율 할인 정책 → 8100원

> 영화별로 하나의 할인 정책만 할당할 수 있음

> 할인 조건은 다수의 할인 조건이 함께 지정가능함

* 순서 조건, 기간 조건을 섞는 것도 가능함

## 2. 객체지향 프로그래밍을 향해

### 협력 객체 클래스

> 객체지향 : 객체를 지향

📢 나는 어떤 방식으로 객체지향을?

> 클래스가 필요한가?

> 클래스를 결정한 후 → 어떤 속성과 메서드를 필요한지

> 하지만 이는 본질이 아님

→ 객체에 초점을 맞출 때 진정한 객체지향

#### 1. 어떤 클래스가 필요한지 고민하기 전에 어떤 객체들이 필요한지 고민하라

> 클래스는 공통적인 상태와 행동을 공유하는 객체들을 추상화

* 클래스의 윤곽을 잡기 위해서는
* 객체들이 → 어떤 상태, 어떤 행동을 가지는지 먼저 결정해야함
* 객체를 중심에 두는 접근 방법은 설계를 단순하고 깔끔하게

#### 2. 객체를 독립적인 존재가 아니라 기능을 구현하기 위해 협력하는 공동체의 일원

> 객체는 홀로 존재하는 것이 아님

* 다른 객체에게 도움
* 의존하면서 살아가는 협력적인 존재

→ 협력에 참여하는 협력자로 바라보기

→ 객체들의 모양과 윤곽이 잡히면 공통된 특성과 상태를 가진 객체들을 → 타입

→ 타입 기반으로 클래스를 구성

### 도메인의 구조를 따르는 프로그래밍 구조

> 도메인

문제를 해결하기 위해 사용자가 프로그램을 사용하는 분야

> 객체지향 패러다임이 강력한 이유

*   요구사항 분석 초기 → 프로그램을 구현하는 마지막 단계까지

    동일한 추상화 기법을 사용할 수 있기 때문임
*   요구사항과 프로그램을 객체라는 동일한 관점에서 바라볼 수 있음

    도메인을 구성하는 개념들이 프로그램의 객체와 매끄럽게 연결

> 클래스의 이름

* 대응되는 도메인 개념의 이름과 동일하거나 적어도 유사하게
* 클래스 사이의 관계도 최대한 도메인 개념사이에 맺어져야 함

### 클래스 구현하기

> 도메인 개념들의 구조를 반영하는 적절한 클래스 구조를 만들었다고 가정

* 남은 일 → 프로그래밍 언어를 이용하여 이 구조를 구현

> Screening 클래스

* 사용자들이 예매하는 대상인 상영을 구현
* 상영할 영화(movie) 순번(sequence), 상영 시작 시간(whenScreened)을 인스턴스 변수로 포함

> 주목할 점

* 인스턴스 변수의 가시성 : private
* 메서드의 가시성 : public
* 클래스를 구현하거나 다른 개발자에 의해 개발된 클래스 사용할 때 중요한 것
  * 클래스의 경계를 구분 짓는 것
*   클래스는 내부와 외부로 구분되며 훌륭한 클래스를 설계하기 위한 핵심

    → 어떤 부분을 외부에 공개하고

    → 어떤 부분을 감출지에 대한 고민

> 외부에서는 객체의 속성에 직접 접근할 수 없도록 막고 → 적절한 public 메서드를 통해서만 내부 상태를 변경

📢 왜 클래스의 내부와 외부를 구분해야 할까요?

> 경계의 명확성이 → 객체의 자율성을 보장

> 더중요한 이유 : 프로그래머에게 구현의 자유를 보장

### 자율적인 객체

> 객체가 상태(state), 행동(behavior)을 함께 가지는 복합적인 존재

> 객체가 스스로 판단하고 행동하는 자율적인 존재

* 많은 사람들은 객체를 상태와 행동을 함께 포함하는 식별 가능한 단위로 정의

> 객체지향 이전의 패러다임 → 데이터와 기능 독립적인 존재를 서로 엮어 프로그램을 구성

*   객체 지향은 객체라는 단위 안에서 → 데이터와 기능을 한 덩어리로 묶음으로써

    문제 영역의 아이디어를 적절하게 표현할 수 있게 함

> 데이터와 기능을 객체 내부로 함께 묶는 것 → 캡슐화

*   이는 상태와 행동을 캡슐화 하는 것만 제공하는 것이 아닌

    외부에서 접근을 제어할 수 있는 `접근 제어` 메커니즘도 제공함

    많은 프로그래밍 언어 → 접근 제어를 위해

    public, protected, private과 같은 접근 수정자를 함께 제공함

📢 객체 내부의 접근을 왜 통제하나요?

객체를 자율적인 존재로 만들기 위해서

* 객체지향 핵심 : 스스로 상태를 관리, 판단, 행동하는 자율적인 객체의 공동체를 구성

> 객체가 자율적인 존재 → 외부의 간섭을 최소화

* 외부에서 객체가 어떤 상태에 놓여 있는지, 어떤 생각을 하고 있는지 알아서는 안됨
* 결정에 직접적으로 개입하려 해서도 안됨

> 캡슐화와 접근 제어 → 객체를 두 부분

1. 외부에서 접근 가능한 부분 → 이를 퍼블릭 인터페이스(public interface)
2. 외부에서 접근 불가, 오직 내부에서 접근 → 이를 구현(implementation)

> 인터페이스와 구현의 분리 원칙 → 훌륭한 객체지향 프로그램을 만들기 위한 핵심 원칙

* 일반적으로 객체의 상태는 숨기고 행동만 외부에 공개
* 클래스의 속성 : private
* 외부 공개 메서드 : public
* 어떤 메서드들이 서브클래스나 내부에서만 접근 가능 → 가시성
  * protected
  * private
* 이때 퍼블릭 인터페이스 : public으로 지정된 메서드만 포함
* 그 밖의 private 메서드나 protected 메서드 속성 → 구현에 포함

### 프로그래머의 자유

> 프로그래머의 역할

* 클래스 작성자(class creator)
* 클라이언트 프로그래머(client progragmmer)
* 클래스 작성자 : 새로운 데이터 타입을 → 프로그램에 추가
* 클라이언트 : 클래스 작성자가 추가한 데이터 타입을 사용

> 클라이언트 프로그래머의 목표

* 필요한 클래스들을 엮어서 → 애플리케이션 안정적으로 구축
* 클래스 작성자 → 프로그래머에게 필요한 부분만 공개
  * 나머지는 꽁꽁 숨겨야 함
  * 이를 통해 클라이언트 프로그래머 → 영향을 걱정하지 않고 → 내부 구현 수정

> 이를 구현 은닉(implementation hiding)

*   접근 제어 매커니즘은 프로그래밍 언어 차원에서

    클래스의 내부와 외부를 명확하게 경계 지을 수 있게 하는 동시에

    클래스 작성자가 내부 구현을 은닉할 수 있게 만듬
* 또한 클라이언트 프로그래머가 실수로 숨겨진 부분에 접근하는 것을 막음

1.  인터페이스만 알고도 클래스를 사용할 수 있기 때문에

    머리속에 담아야하는 지식의 양을 줄일 수 있음
2.  클래스 작성자는 인터페이스를 바꾸지 않는 한

    외부에 미치는 영향을 걱정하지 않고 → 내부 구현을 마음대로 변경 가능

📢 설계가 필요한 이유 : 변경을 관리하기 위해서라는 것을 기억 객체지향 언어는 객체 사이의 의존성을 적절히 관리함으로 변경에 대한 파급효과를 제어할 수 있는 다양한 방법을 제공함 객체 변경을 관리할 수 있는 기법 중에서 → 가장 대표적인 것 \`접근제어\` 변경될 가능성이 있는 세부적인 구현 내용을 private 영역 안에 감춤으로 변경으로 인한 혼란을 최소화 할 수 있음

### 협력하는 객체들의 공동체

> 1장 금액을 구현하기 위해서 Long 타입을 사용

*   변수의 크기나 연산자의 종류와 관련된 구현 관점에서

    제약 자체는 표현할 수 잇음
* 금액과 관련된 로직이 서로 다른 곳에서 중복되어 구현되는 것을 막을 수
* 저장하는 값이 금액과 관련돼 있다는 의미를 전달 불가

> Money 타입

* 객체지향의 장점 객체를 이용해 도메인의 의미를 풍부하게 표현할 수 있다는 것
*   의미를 좀 더 명시적이고 분명하게 표현할 수 있다면

    객체를 사용해서 해당 개념을 구현하는 것이 좋음
*   비록 하나의 인스턴스 변수만 포함하더라도 개념을 명시적으로 표현하는 것은 전체적인 설계

    명확성과 유연성을 높히는 방법

📢 Type 명시가 이런의미가 아닐까?

### 협력에 관한 짧은 이야기

> 객체의 내부 상태는 외부에서 접근하지 못하도록 감춰야 함

> 대신 외부에 공개하는 퍼블릭 인터페이스를 통해 내부 상태에 접근할 수 있또록 허용

* 객체는 다른 객체의 인터페이스에 공개된 행동을 수행하도록 요청
* 요청을 받은 객체는 자율적인 방법에 따라 요청을 처리후 → 응답

> 객체가 다른 객체와 상호작용 하는것은
>
> 메시지를 전송하는 것 뿐임

→ 수신된 메시지를 처리하기 위한 자신만의 방법 → 메서드(method)

* 메시지와 메서드를 구분하는 것은 매우 중요함
*   객체지향 패러다임이 유연하고

    * 확장 가능하며
    * 재사용 가능한 설계를 낳는다는 명성

    → 메시지와 메서드를 명확하게 구분한 것도 단단히 한몫

> 메시지와 메서드의 구분에서부터 → 다형성(polymorphism)의 개념이 출발

*   지금까지 Screening이 Movie의 calculateMovieFee 메서드를 호출한다

    → 이는 Screening이 Move에게 calculateMovieFee 메시지를 전송한다라고 말하는 것이 타당
*   사실 Screening은 Movie 안에 calculateMovieFee 메서드가 존재하는 사실 조차 모름

    → 맹목적인 믿음을 가지고 메시지를 전송할 뿐

> 메시지를 수신한 Movie는 스스로 적절한 메서드를 선택함

* 메시지를 처리하는 방법을 결정하는 것은 Movie 스스로의 문제
* 객체가 메시지를 처리하는 방법을 자율적으로 경정할 수 있다는 것의 이유

📢 말이 안되는데요?

> Java와 같은 정적 타입 언어는 해당되지 않지만 루비나 스몰토크 같은 동적 타입언어는 calculateMovieFee가 아닌 다른 시그니처를 가진 메서드를 통해서도 해당 메시지에 응답할 수 있음

## 3. 할인 요금 구하기

### 할인 요금 계산을 위한 협력 시작하기

> Movie

* 제목
* 상영시간
* 기본요금
* 할인 정책

```java
public class Movie {
	private String title;
	private Duration runningTime;
	private Money Fee;
	private DiscountPolicy discountPolicy;

	public Movie(String title, Duration runningTime, Money fee, DscountPolicy discountPolicy) {
	 this.title = title;
	 this.runningTime = runningTime;
	 this.fee = fee;
	 this.discountPolicy = discountPolicy;
	}

	public Money getFee() {
		return fee;
	}
	
	public Money calculateMoveFee(Screening screening) {
		return fee.minus(discountPolicy, calculateDsicountAmount(screening)):
	}
}
```

> 메서드의 이상한 점

* 어떤 할인 정책을 사용할건지 결정하는 코드가 존재하지 않음

> 이는 객체지향 패러다임에 익숙하지 않음

* 하나는 상속(inheritance)
* 하나는 다형성
  * 그 기반에는 추상화

### 할인 정책과 할인 조건

할인 정책 : 금액 할인 정책, 비율 할인 정책으로 구분

> 두 클래스는 대부분의 코드가 유사
>
> but 할인 요금을 계산하는 방식만 조금 다름

*   두 클래스 사이의 중복 코드를 제거하기 위해

    공통으로 코드를 보관할 장소가 필요함

> 여기서 부모 클래스인 DiscountPolicy 안에 중복 코드를 두고
>
> AmountDiscountPolicy와 PercentDiscountPolicy가 이 클래스를 상속 받도록
>
> 실제 애플리케이션에는 DiscountPolicy의 인스턴스를 생성할 필요가
>
> 추상 클래스(abstract class)

```java
public abstract class DiscountPolicy {
	private List<DiscountCondition> conditions = new ArrayList<>();
	
	public DiscountPolicy(DiscountCondition ... conditions) {
		this.conditions = Arrays.asList(conditions);
	}

	public Money calculateDiscountAmount(Screening screening) {
		for (DiscountCondition each : conditions) {
			if (each.isSatisfedBy(screening)) {
				return getDiscountAmount(screening);
			}
		}
		return Money.ZERO;
	}
	
	abstract protected Money getDiscountAmount(Screening Screening);
}
```

> DiscountPolicy는 DiscountCondition의 리스트인 conditions를 인스턴스 변수로 가지기 때문에
>
> 하나의 할인 정책은 여러 개의 할인 조건을 포함할 수 있음

> 각각이 할인조건 만족 → true

> 만족시키지 못할 경우 → false

* 할인 조건을 만족하는 DiscountCondition이 하나라도 존재하는 경우
  * 추상 메서드(abstract method)인 getDiscountAmount 메서드를 호출해 할인 요금 계산
* 만족하는 할인 조건이 하나도 존재하지 않는다면 → 할인 요금으로 0원을 반환
*   DiscountPolicy는 할인 여부와 요금 계산에 필요한 전체적인 흐름은 정의하지만

    실제로 요금을 계산하는 부분은 추상 메서드인 getDiscountAmount 메서드에게 위임

    실제는 DiscountPolicy를 상속 받은 자식 클래스에서 오버라이딩한 메서드가 실행
*   이처럼 부모 클래스에 기본적인 알고리즘의 흐름을 구현하고

    중간에 필요한 처리를 자식 클래스에게 위임하는 디자인 패턴

    > TEMPLATE METHOD 패턴

> DiscountCondition은 자바의 인터페이스를 이용해 선언

*   isSatisfiedBy 오퍼레이션은 인자로 전달된

    screening이 할인 가능한 경우 → true를 반환하고

    할인이 불가능한 경우 → false

> SequenceCondition은 할인 여부를 판단하기 위해 사용할 순번을
>
> `인스턴스 변수`로 포함함
>
> isSatisfiedBy 메서드는 파라미터로 전달된 Screening의 상영 순번과 일치할 경우
>
> 할인 가능한 것으로 판단해서 true를
>
> 그렇지 않을 경우 false

```java
public class SequenceCondition implements DiscountCondition {
	private int sequence;

	public SequenceCondition(int sequence) {
		this.sequence = sequence;
	}

	public boolean isSatisfiedBy(Screening screening {
		return screening.isSequence(sequence);
	}
}
```

> PrriodCondition은 상영 시간이 특정한 기간 안에 포함되는지 여부를 판단해
>
> 할인 여부를 결정함
>
> 조건에 사용할 요일(dayOfWeek)과 시작 시간(startTime), 종료 시간(endTime)을 인스턴스 변수로 포함

```java
public class PeriodCondition implements DiscountCondition {
	private DayOfWeek dayOfWeek;
	private LocalTime startTime;
	private LocalTime endTime;

	public PeriodCondition(DayOfWeek dayOfWeek, LocalTime startTime, LocalTime endTime {
		this.dayOfWeek = dayOfWeek;
		this.startTime = startTime;
		this.endTime = endTime;
	}
	
	public boolean isStatisfiedBy(Screening screening) {
		return screening.getStartTime().getDayOfWeek().equals(dayOfWeek) 
	}
}
```

> 이제 할인 정책을 구현

* AmountDiscountPolicy는 DiscountPolicy의 자식 클래스로서 할인 조건을 만족할 경우
  * 일정한 금액을 할인해주는 할인 정책을 구현
  * 이 클래스는 DiscountPolicy의 getDiscountAmount 메서드를 오버라이딩
  * 할인 요금은 인스턴스 변수인 → discountAmount에 저장

```java
public class AmountDiscountPolicy extends DiscountPolicy {
	private Money dsicountAmount;

	public AmountDiscountPolicy(Money discountAmount, DiscountCondition ... conditions) {
		super(conditions)
		this.discountAmount = discountAmount;
		@Override
		protected Money getDiscountAmount(Screening screening){ 
			return discountAmount;
		}
	}
}
```

> PercentDiscountPolicy 역시 DiscountPolicy의 자식 클래스로서
>
> getDiscountAmount 메서드를 오버라이딩 함
>
> AmountDiscountPolicy와 다른 점이라면
>
> 고정 금액이 아닌 일정 비율을 차감한다는 것임
>
> 할인 비율은 → 인스턴스 변수인 → percent에 저장

📢 오버라이딩과 오버로딩

> 많은 사람들이 오버라이딩과 오버로딩의 개념을 혼동함

오버라이딩 : 부모 클래스에 정의된 같은 이름, 파라미터 목록을 가진 메서드를

자식 클래스에서 재정의 하는 경우를 가리킴

자식 클래스의 메서드 : 오버라이딩한 부모 클래스의 메서드를 가리키기 때문에

외부에서도 부모 클래스의 메서드가 보이지 않음

> 오버로딩 : 메서드의 이름은 같지만 제공되는 파라미터의 목록이 다름
>
> 오버로딩한 메서드는 원래의 메서드를 가리지 않기 때문에 이 메서드들은 사이 좋게 공존

* 오버로딩의 예

```java
Money 클래스에 구현된 plus 메서드는 이름은 같지만
하나는 Money 타입의 파라미터를
다른 하나는 long 타입의 파라미터를 받도록 정의돼 있음
이 경우 두 메서드는 공존하며 -> 외부에서는 두 개의 메서드를 호출 간으함
이 경우 오버로딩이라 부름

public class Money {
 public Money plus(Money amount) {
	return new Money(this.amount.add(amount.amount));		
 }

 public Money plus(long amount) {
		return new Money(this.amount.add(BigDecimal.valueOf(amount));
	}
}
```

### 할인 정책 구성하기

> 하나의 영화에 대해 → 단 하나의 할인 정책만 설정 가능

> But : 할인 조건 → 여러개를 적용 가능함

## 4. 상속과 다형성

> Movie 클래스는 어디에서도 할인 정책이 금액 할인 정책인지
>
> 비율 할인 정책인지를 판단하지 않음

❓ 할인 정책을 결정하는 조건문이 없는데도 불구하고 어떻게 영화 요금을 계산할 때 할인 정책과 비율 할인 정책을 선택할 수 있을까?

> 이를 답변하기 위해서는 상속과 다형성을 이해

### 컴파일 시간 의존성과 실행 시간 의존성

> 어떤 클래스가 다른 클래스에 접근할 수 있는 경로를 가지거나
>
> 해당 클래스의 객체의 메서드를 호출할 경우
>
> 두 클래스 사이에 의존성이 존재한다고 말함

* 여기서 눈 여기ㅕ 볼점 : Movie 클래스가 DiscountPolicy 클래스와 연결

문제는 영화 요금을 계산하기 위해서는

추상 클래스인 DiscountPolicy가 아니라 AmountDiscountPolicy 와 PercentDiscountPolicy 인스턴스가 필요함

따라서 Movie의 인스턴스는 실행시에 AmountDiscountPolcy나 PercentDiscount의 인스턴스에 의존

하지만 코드 수준 → Movie 클래스는 두 클래스 중 → 어떤 것에도 의존하지 않음

오직 추상 클래스인 DiscountPolicy에만 의존하고 있음

❓ 그러면 인스턴스가 코드 작성 시점에서 존재조차 알지 못했던 다른 인스턴스와 실행 시점에 협력 가능한 이유는 무엇일까?

> Movie 인스턴스를 생성하는 코드를 살펴보기

* 생성자에서 DiscountPolicy 타입의 객체를 인자로 받았던 것을 기억
* 만약 영화 요금을 계산하기 위해 금액 할인 정책을 적용하고 싶다면
* Movie 인스턴스를 생할 때 인자로 AmountDiscountPolicy의 인스턴스를 전달하면 됨

```java
Movie avatar = new Movie({"아바타", Duration.ofMinutes(120)}, new AmountDiscountPolicy(Money.wons(800)});
```

> 이제 실행 시에 Movie의 인스턴스는 AmountDiscountPolicy 클래스의 인스턴스에 의존하게 될 것

*   영화 요금을 계산하기 위해 비율 할인 정책을 적용하고 싶다면

    AmountDiscountPolicy 대신 PercentDiscountPolicy의 인스턴스를 전달하면 됨

```java
Moive avatar = new Move (new PercentDiscountPolicy(0.1);
```

* 이 경우 → Movie의 인스턴스는 PercentDiscountPolicy의 인스턴스에 의존
* 코드 상에서 Movie는 DiscountPolicy에 의존
  * 코드를 샅샅이 조사해봐도

> 코드의 의존성과 실행 시점의 의존성이 서로 다를 수 있음

* 클래스 사이의 의존성과 객체 사이의 의존성은 동일하지 않음

> 유연하고, 쉽게 재사용할 수 있으며
>
> 확장 가능한 객체지향 설계가 가지는 특징은 코드의 의존성과
>
> 실행 시점의 의존성이 다름

💡 한 가지 간과 해서는 안될 사실

> 코드의 의존성과 실행 시점의 의존성이 다르면 다를수록
>
> 코드를 이해하기 어려워짐
>
> 코드를 이해하기 위해서는 코드뿐만 아니라
>
> 객체를 생성하고 연결하는 부분을 찾아야 함

> `코드의 의존성`과 `실행 시점의 의존성`이 다르면 다를수록
>
> 코드는 더 유연해지고 확장 가능해짐
>
> 같은 의존성의 양면성은
>
> 설계가 트레이드오프의 산물이라는 사실

> 현재 Movie 인스턴스가 어떤 객체에 의존하고 있는지 알고 있는가?
>
> Movie 클래스의 코드만 살펴보는 것으로는 해답을 얻을 수 없음

> 의존하고 있는 객체의 정확한 타입을 알기 위해서는
>
> 의존성을 연결하는 부분을 찾아봐야함
>
> 이 경우 → Movie 인스턴스를 생성하는 부분을 찾아 ⇒ 생성자에 전달되는 객체가
>
> AmountDiscountPolicy의 인스턴스인지
>
> PercentDiscountPolicy의 인스턴스인지를 확인한 후
>
> 의존성의 대상이 무엇인지를 알 수 있음

> 설계가 유연해질수록 코드를 이해하고 디버깅하기는 점점 더 어려워짐
>
> 반면 유연성을 억제하면 → 코드를 이해하고 디버깅은 쉬움
>
> But 재사용성과 확장 가능성은 낮아짐

> 훌륭한 객체지향 설계자로 성장하기 위해서는

항상 유연성과 가독성 사이에서 고민해야함

무조건 유연한 설계도, 무조건 읽기 쉬운 코드도 정답이 아님

💡 코드 상에 존재하는 Movie 클래스에서 DiscountPolicy 클래스로의 의존성이 어떻게 실행 시점에는 AmountPolicy나 PercentDiscountPolicy 인스턴스에 대한 의존성으로 바뀔 수 있나?

### 차이에 의한 프로그래밍

> 클래스를 하나 추가하고 싶은데 그 클래스가 기존의 어떤 클래스와 매우 흡사하다고 가정
>
> 그 클래스의 코드를 가져와 약간만 추가하거나
>
> 수정해서 → 새로운 클래스를 만들 수 있다면 좋을 것임
>
> 더 좋은 방법 → 그 클래스의 코드를 전혀 수정하지 않고도 → 재사용

* 이를 가능하게 해주는 방법이 바로 상속

💡 상속

> 코드를 재사용하기 위해 가장 널리 사용되는 방법

*   상속을 이용하면 → 클래스 사이에 관계를 설정하는 것만으로 기존

    클래스가 가지고 있는 모든 속성과 행동을 새로운 클래스에 포함시킬 수 있음

> 장점

* 기존 클래스 기반으로 새로운 클래스를 쉽고 빠르게 추가할 수 있는 간편한 방법을 제공함
* 상속을 이용하면 부모 클래스의 구현은 공유하면서도 행동이 다른 자식 클래스를 쉽게 추가
  * AmountDiscountPolicy와 PercentDiscountPolicy에서 정의한 추상 메서드인
  * getDiscountAmount 메서드를 오버라이딩해서 DiscountPolicy의 행동을 수정한다는 것

> 차이에 의한 프로그래밍(programming bydffirence)

* 부모 클래스와 다른 부분만을 추가해서 새로운 클래스 쉽고 빠르게 만드는 방법

💡 자식 클래스와 부모 클래스

> 상속은 두 클래스 사이의 관계를 정의하는 방법

*   상속 관계를 선언함으로 한 클래스 → 자동으로 다른 클래스가 제공하는 코드를

    자신의 일부로 합칠 수 있음
* 따라서 상속을 사용하면 중복을 제거하고 → 여러 클래스 사이에서 동일한 코드 사용 가능

### 상속과 인터페이스

> 상속이 가치 있는 이유

* 부모 클래스가 제공하는 모든 인터페이스를 자식 클래스가 물려 받을 수 있기 때문
  * 상속을 바라보는 일반적인 인식과는 거리가 있음

💡 상속의 목적은 메서드나 인스턴스 변수를 재사용한는거 아닌가요?

> 인터페이스는 객체가 이해할 수 있는 메시지의 목록을 정의하는 것을 기억

* 상속을 통해 자식클래스 → 자신의 인터페이스에 부모 클래스의 인터페이스를 포함
* 결과적으로 자식 클래스는 부모 클래스의 인터페이스를 포함하게 됨
* 자식 클래스는 부모 클래스가 수신할 수 있는 모든 메시지를 수신할 수 있음
  * 외부 객체는 자식 클래스를 부모 클래스와 동일한 타입으로 간주

```java
public class Movie {
	public Money calculateMoveFee(Screening screening) {
		return fee.minus(discountPolicy.calculaterDiscountAmount(screening));
	}
}
```

> Movie가 DiscountPolicy의 인터페이스에 정의된 calculateDiscountAmount 메시지를 전송하고 있음

DiscountPolicy를 상속받는 AmountDiscountPolicy와 PercentDiscountPolicy의 인터페이스에도

> Movie 입장에서는 자신과 협력하는 객체가 어떤 클래스의 인스턴스인지가 중요한 것이 아니라
>
> 메시지를 수신할 수 있따는 사실이 중요함

> 다시 말해 → 메시지를 이해할 수 만 있다면
>
> 그 객체가 어떤 클래스의 인스턴스인지 상관하지 않는다는 것
>
> 따라서 메시지를 수신할 수 있는 AmountDiscountPolicy와 PercentDiscountPolicy 모두
>
> DiscountPolicy를 대신해서 Movie와 협력

### 다형성

> 다시 한번 강조하지만 메시지와 메서드는 다른 개념

💡 실행되는 메서드는 무엇인가?

* 오버라이딩한 메서드가 실행될 것

상호 작용하기 위해 연결된 객체의 클래스가 무엇인가에 따라 달라짐

*   Movie와 협력하는 객체가 인스턴스라면

    오버라이딩한 메서드가 실행될 것임

> 코드 상에서 Movie 클래스 DiscountPolicy 클래스에게 메시지를 전달하지만
>
> 실행 시점에 실제로 실행되는 메서드는 Movie와 협력하는 실제 클래스가 무엇인지에 따라 달라짐
>
> 다시 말해 동일한 메시지를 전달하지만 어떤 메서드가 실행될 것인지는 메시지를 수신하는
>
> 객체의 클래스가 무엇이냐에 따라 달라짐

> 이를 다형성

### 인터페이스와 다형성

> 종종 구현은 공유할 필요가 없고 → 순수하게 인터페이스만 공유하고 싶을 때가 있음

이를 위해 → 인터페이스라는 프로그래밍 요소를 제공함

## 5. 추상화와 유연성

### 추상화의 힘

💡 추상적인 이유

> 인터페이스에 초점을 맞췄기 때문

* 모든 정책을 수신할 수 있는 메시지를 정의
*   둘 다 같은 계층에 속하는 클래스들이 공통으로 가질 수 있는 인터페이스를 정의하며

    구현의 일부(추상 클래스인 경우) 또는 전체(자바 인터페이스인 경우)를

    자식 클래스가 결정할 수 있도록 결정권을 위임함

> 자식 클래스를 생략한 구조

* 추상화를 사용할 경우의 두 가지 장점

1. 추상화의 계층만 따로 빼놓고 보면 → 요구사항의 정책을 높은 수준에서 서술할 수 있음
2. 추상화를 이용하면 설계가 좀 더 유연해짐

> 영화 예매 요금은 최대 하나의 할인 정책과 다수의 할인 조건을 이용해 계산할 수 있음

* 이 문장 자체는
  * 영화의 예매 요금은
    * 금액 할인 정책과
    * 두 개의 순서 조건
    * 한 개의 기간 조건을 이용해서 계산할 수 있다.

> 이것은 할인 정책과 할인 조건이라는 좀 더 추상적인 개념들을 이용해서 문장을 작성

💡 추상화 이용의 장점

> 세부적인 내용을 무시한 채 상위 정책을 쉽고 간단하게 표현할 수 있음

이런 특징은 세부사항에 억눌리지 않고 → 상위 개념만으로도 도메인의 중요한 개념을 설명할 수 있게 함

> 추상화를 이용해 상위 정책을 기술 → 기본적인 애플리케이션의 협력 흐름을 기술한다는 것을 의미함

> 재사용 가능한 설계의 기본을 이루는 디자인 패턴, 프레임워크 모두
>
> 추상화를 이용해 상위 정책을 정의하는 객체지향의 메커니즘을 활용하고 있기 때문

> 두 번째 특징은 첫 번째 특징으로부터 유추 가능함
>
> 추상화를 이용해 상위 정책을 표현하면 기존의 구조를 수정하지 않고도 새로운 기능을 쉽게 추가, 확장 가능함
>
> 다시 말해 설계를 유연하게 만들 수 있음

### 유연한 설계

> 스타워즈의 할인 정책

* 할인 요금을 계산할 필요 없이 영화에 설정된 기본 금액을 그대로 사용

> 이 방식의 문제점

* 할인 정책이 없는 경우를 예외 케이스로 취급
  * 지금까지 일관성 있ㄴ던 협력 방식이 무너지게 된다는 것
  * 기존 할인 정책의 경우에는 할인 금액이 0원이라는 사실을 결정하는 것이
  * 자식 클래스에 존재 했지만 → 지금은 다른 클래스

> 책임의 위치를 결정하기 위해 조건문을 사용한느 것은 대부분의 경우 좋지 않은 선택

> 항상 예외 케이스를 최소화 하고 일관성을 유지할 수 있는 방법을 선택

```java
public class Movie {
	public Money calculateMoveFee(Screening screening) {
		if (discountPolicy == null) {
			return fee;
		}
	}
	return fee.minus(discountPolcy.calculateDiscountAmount(screening));
}
```

> 할인 요금을 계산할 책임을 그대로 → DiscountPolicy 계층에 유지시키는 것임

```java
public class NoneDiscountPolicy extends DiscountPolicy {
	@Override
	protected Money getDiscountAmount(Screening screening) {
		return Money.ZERO;
	}
}
```

💡 분기문을 이용한 로직 처리

> 어느 것이 더 좋은지 모르겠음

이를 통해서 클래스를 상속받아 → 새로운 클래스로 로직을 처리하는 것

1. 기존 로직에서 이를 처리하는 것

> 추상화가 유연한 설계를 가능하게 하는 이유

* 설계가 구체적인 상황에 결합되는 것을 방지하기 때문임
* Movie는 특정한 할인 정책에 묶이지 않음
*   할인 정책을 구현한 클래스가 DiscountPolicy를 상속 받고 있따면

    어떤 클래스와도 협력이 가능함

> 컨텍스트 독립성 → 유연한 설계가 필수이적인 분야에서 진가를 발휘

### 추상 클래스와 인터페이스 트레이드오프

> 현재의 문제점

* getDiscountAmount() 메서드가 어떤 값을 반환하던 상관이 없는 코드
  * 부모 클래스인 DiscountPolicy에서 할인 조건이 없을 경우
  * getDiscountAmount() 메서드를 호출하지 않기 때문
* 부모 글래스인 DiscountPolicy와 NoneDiscountPolicy를 개념적으로 결합
  * NondeDiscountPolicy의 개발자는 getDiscountAmount()가 호출되지 않는다면
  * DiscountPolicy가 0원을 반환할 것이라는 사실을 가정하고 있기 때문

💡 그럼 어떻게 해결하나요?

> Discount 클래스를 인터페이스로 변경

```java
public interface DiscountPolicy {
	Money calcaulateDiscountAmount(Screening screening);
}
```

> 원래의 DiscountPolicy 클래스의 이름을 DefaultDiscountPolicy로 변경하고 인터페이스를 구현하도록 설정

```java
public abstract class DefaultDiscountPolicy implements DiscountPolicy {
 ---
}
```

> 이제 NoneDiscountPolicy가 DiscountPolicy 인터페이스를 구현하도록 변경하면
>
> 개념적인 혼란과 결합을 제거할 수 있음

```java
public class NoneDiscountPolicy implements DiscountPolicy {
	@Override
	public Money calculateDiscountAmount(Screening screening) {
		return Money.ZERO;
	}
}
```

💡 어떤 설계가 더 좋은가?

> 이상적으로는 인터페이스를 사용하도록 변경한 설계가 더 좋음

> 하지만 현실적 → NoneDiscountPolicy만을 위한 인터페이스를 추가하는 것이 과하다는 생각이 들 수 있음

> 어쨌든 변경 전의 NoneDiscountPolicy 클래스 역시 할인 금액이 0원 이라는 사실을 효과적으로 전달하기 때문임

> 여기서 이야기하고 싶은 사실은 구현과 관련된 모든 것들이 트레이드오프의 대상이 될 수 있다는 사실임
>
> 우리가 작성하는 코드에는 합당한 이유가 있어야함
>
> 아주 사소한 결정이라도 트레이드오프를 통해 얻어진 결론과 그렇지 않은 결론 차이는 크다
>
> 고민하고 트레이드 오프 해라

### 코드 재사용

> 상속은 코드를 재사용하기 위해 많이 사용

→ 상속 보다는 합성(composition)이 더 좋은 방법이라는 이야기

💡 상속 대신 합성을 많이 사용 하는 이유는 무엇일까?

### 상속

> 상속 : 코드를 재사용하기 위해 널리 사용되는 기법

하지만 두 가지 관점에서 설계에 안좋은 영향을 미침

1.  캡슐화를 위반함

    상속을 이용하기 위해서는 부모 클래스의 내부 구조를 잘 알고 있어야함

    개발자는 부모 클래스의 메서드안 안에서 추상 메서드를 호출 한다는 사실을 알고 있어야함

    > 결과적으로 부모 클래스의 구현이 → 자식 클래스에서 노출되기 때문에 캡슐화가 어려워짐

    * 캡슐화의 약화는 자식 클래스 → 부모 클래스에게 강하게 결합되도록 만듬
    * 부모 클래스를 변경할 때 자식 클래스도 함께 변경될 확률을 높힘
2.  설계가 유연하지 않음

    상속은 부모 클래스와 자식 클래스 사이의 관계를 컴파일 시점에서 결정

    따라서 실행 시점에서 객체의 종류를 변경하는 것이 불가능함

    > 상속을 이용한 설계

    대부분의 언어에서 이미 생성된 객체의 클래스를 변경하는 기능을 지원하지 않음

    이 문제 해결 → 인스턴스를 생성한 후 → 상태를 복사하는 것 뿐

> 인스턴스 변수로 연결한 기존 방법 → 실행 시점에 결정

```java
public class Movie {
	private DiscountPolicy discountPolicy;

	public void changeDiscountPolicy(DiscountPolicy discountPolicy) {
		this.discountPoicy = discountPolicy;
	}
}
```

> 금액 할인 정책이 적용된 영화에 비율 할인 정책이 작용되도록 변경하는 것은
>
> 새로운 DiscountPolicy 인스턴스를 연결하는 간단한 작업

```java
Movie avatar = new Movie();

avatar.changeDiscountPolicy(new PercentDiscountPoicy(0.1));
```

> 이 예제를 통해서 상속보다 인스턴스 변수로 관계를 연결한 원래의 설계가 더 유연하다는 사실
>
> Movie가 DiscountPolicy를 포함하는 이 방법 역시 코드를 재사용하는 방버이라는 점을 눈여겨 보기
>
> Movie가 DiscountPollcy의 코드를 재사용하는 이 방법은 너무나도 유용
>
> 특별한 이름으로 불림

### 합성

> 차이점

* 상속
  * 부모 클래스의 코드와 자식 클래스의 코드를 컴파일 시점에 하나의 단위로 강하게 결합
* 합성
  * 인터페이스를 이용해 약하게 결합
  * 외부에 메서드를 제공한다는 사실만 알고 내부 구현에 대해서는 전혀 알지 못함
  * 이처럼 인터페이스에 정의된 메시지를 통해서만 코드를 재사용하는 방법을 합성

> 합성은 상속이 가지는 문제점을 해결

1.  인터페이스에 정의된 메시지를 통해서만 재사용이 가능

    구현을 효과적으로 → 캡슐화
2. 의존하는 인스턴스를 교체하는 것이 비교적 쉽기 때문에 설계를 유연하게 만듬

* 상속은 클래스를 통해 강하게 결합되는 데 비해
* 합성 : 메시지를 통해 느슨하게 결합

💡 그럼 상속을 사용하지 말라는 말 인가요?

> 설계에서는 상속과 합성을 함께 사용해야함

* 코드를 재사용하는 경우에는 상속보다 → 합성
* 다형성을 위해 인터페이스를 재사용 → 상속과 합성을 함께 조합해서 사용

💡 본질

> 객체지향이란 객체를 지향하는 것

객체지향 패러다임의 중심에는 객체가 위치함

그러나 각 객체를 따로 떼어 놓고 이야기하는 것은 무의미함

가장 중요한 것 : 애플리케이션 기능을 구현하기 위해 협력에 참여하는 객체들 사이의 상호작용

객체들은 협력에 참여하기 위해 역할을 부여받고 역할에 적합한 책임을 수행함

> 객체지향의 설계의 핵심은 적절한 협력을 식별하고
>
> 협력에 필요한 역할을 정의한 후에
>
> 역할을 수행할 수 있는 적절한 객체에게 적절한 책임을 할당하는 것
