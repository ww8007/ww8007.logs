# 😆 5. OBJ 책임 할당하기



## 5. 책임 할당하기

💡 오직 하나의 작업만 수행하고 하나의 변경 이유만 가지는 작고 명확하고 응집도가 높은 메서드로 구성

### 들어가면서

> 데이터 중심의 프로그래밍의 문제점

* 데이터가 아닌 책임에 초점을 맞추는 것임

❓ 왜 책임이 어렵나요?

> 어떤 객체에게 어떤 책임을 할당할지를 결정하기가 쉽지 않음

* 책임 할당 과정은 일종의 트레이드오프 활동
* 동일한 문제를 해결할 수 있는 다양한 책임 할당 방법이 존재하며
* 어떤 방법이 최선인지는 → 상황과 문맥에 따라 달라짐

> 올바른 책임을 할당하기 위해서는 다양한 관점에서 설계를 평가

> GRASP 패턴

## 1. 책임 주도 설계를 향해

> 데이터 중심의 설계 → 책임 중심의 설계로 전환하기 위해서는 다음의 두 가지 원칙

1. 데이터보다 행동을 먼저 결정
2. 협력이라는 문맥 안에서 책임을 결정

> 데이터가 아닌 객체의 책임과 협력에 초점을 맞추는 것

### 데이터보다 행동을 먼저 결정

> 객체에서 중요한 것 : 데이터가 아닌 외부에 제공하는 행동

* 클라이언트 관점 : 객체가 수행하는 행동 → 곧 객체의 책임
  * 객체는 협력에 참여하기 위해 존재하며
  * 협력 안에서 수행하는 책임이 객체의 존재가치를 증명함
* 데이터는 객체가 책임을 수행하는 데 필요한 재료를 제공할 뿐임

❓ 알겠는데 어떻게 함

* 객체의 데이터에서 행동으로 무게중심을 옮기기 위한 기법

> 가장 기본적인 해결방법

* 객체를 설계하기 위한 질문의 순서를 바꾸는 것
* 데이터 중심의 설계에서는

1. 이 객체가 포함해야 하는 데이터가 무엇인가
2. 데이터를 처리하는 데 필요한 오퍼레이션은 무엇인가
3. 이 책임을 수행하는 데 필요한 데이터는 무엇인가?

> 다시 말해 책임 중심의 설계에서는 객체의 행동
>
> 즉 : 책임을 먼저 결정하고 → 객체의 상태를 결정함

* 객체지향 설계에서 가장 중요한 것은
  * 적절한 객체에게 → 적절한 책임을 할당해야 하는 것

❓ 말은 쉽지만 어떻게 해야 하는지 막막함

### 협력이라는 문맥 안에서 책임을 결정

> 객체에게 할당된 책임의 품질

* 협력에 적합한 정도로 결정됨
* 객체에게 할당된 책임이 협력에 어울리지 않는다면 → 그 책임은 나쁜 것임
* 객체의 입장에서 책임이 조금 어색해 보이더라도 협력에 적합 → 그 책임은 좋은 것임

> 책임은 객체의 입장이 아닌 → 객체가 참여하는 협력에 적합해야 함

> 이 사실 : 객체의 책임을 어떻게 식별해야 하는가에 대한 힌트를 제공함

* 협력을 시작하는 주체 : 메시지 전송자
* 협력에 적합한 책임 : 수신자가 아닌 → 전송자에게 적합한 책임
  * 메시지를 전송하는 클라이언트에 의도에 적합한 책임을 할당해야 함
* 협력에 적합한 책임을 수확하기 위해서는
  * 객체를 결정한 후에 메시지를 선택하는 것이 아닌
  * 메시지를 결정한 후에 → 객체를 선택하는 것

> 메시지가 존재하기 때문에 → 그 메시지를 처리할 객체가 필요한 것
>
> 객체가 메시지를 선택하는 것이 아닌 → 메시지가 객체를 선택하도록

❓ 메시지 기반 설계의 장점

> 클래스 기반 설계 관점보다 훨씬 유연한 애플리케이션을 만들 수 있게 해줌
>
> 이 클래스가 필요한 것은 알아. 근데 뭘 해야 하지? 라는 질문을 하는 것이 아닌
>
> `메시지를 전송해야 하는데 누구에게 전송하지?`

> 메시지가 클라이언트의 의도를 표현한다는 사실과
>
> 객체를 결정하기 전에 객체가 수신할 메시지를 먼저 결정한다는 점을 기억하기

* 클라이언트 : 어떤 객체가 메시지를 수신할지 모름
* 단지 임의의 객체가 메시지를 수신할거라는 사실을 믿고 → 자신의 의도를 표현할 메시지를 전달함
* 메시지를 수신할 객체 → 책임을 할당받음

❄️ 메시지 송신자는 메시지 수신자에 대한 어떠한 가정도 할 수 없음 이 관점에서 메시지 수신자가 깔끔하게 캡슐화 데이터 중심의 설계가 캡슐화에 취약한 반면 협력이라는 문맥 안에서 메시지에 집중하는 책임 중심 설계 : 캡슐화의 원리를 지키기 훨씬 쉬워짐

### 책임 주도 설계

1. 시스템이 사용자에게 제공해야 하는 기능인 시스템 책임을 파악함
2. 시스템 책임을 더 작은 책임으로 분할함
3. 분할된 책임을 수행할 수 있는 적절한 객체 또는 역할을 찾아 책임을 할당함
4. 객체가 책임을 수행하는 도중 다른 객체의 도움이 필요한 경우 → 이를 책임질 적절한 객체 또는 역할을 찾음
5. 해당 객체 또는 역할에게 책임을 할당함으로써 두 객체가 협력함

## 2. 책임 할당을 위한 GRASP 패턴

### 도메인 개념에서 출발하기

* 도메인에 대한 개략적인 모습을 그려 보는 것이 유용함
*   도메인 아에서 무수히 많은 개념들이 존재하며 → 개념들을 책임 할당으로 사용하면

    코드에 도메인 모습을 투영하기로 좀 더 수월해짐
* 따라서 어떤 책임을 할당해야 할 때 가장 먼저 고민해야 하는 유력한 후보 : 바로 도메인 개념

### 정보 전문가에게 책임을 할당하라

#### 첫 번째 질문

> 메시지를 전송할 객체는 무엇을 원하는가?

* EX) 1 : 예매하라

> 메시지를 수신할 적합한 객체는 누구인가?

❄️ 객체가 상태와 행동을 통합한 캡슐화의 단위라는 사실에 집중해야 함 객체는 자신의 상태를 스스로 처리하는 자율적인 존재여야 함 객체의 책임과 책임을 수행하는 데 필요한 상태는 동일한 객체 안에 존재해야 함

#### INFORMATION EXPERT 패턴

* 책임을 객체에게 할당하는 일반적인 원리는 무엇인가?

> 즉 : 책임을 수행하는 데 필요한 정보를 가지고 있는 객체에게 할당하라

* 객체가 자율적인 존재여야 한다는 사실을 다시 한번 상기시킴
* 정보를 알고 있는 객체만이 책임을 어떻게 수행할지 스스로 결정할 수 있기 때문
*   INFORMATION EXPERT 패턴을 따라서 정보와 행동을 최대한 가까운 곳에

    위치시키는 때문에 캡슐화를 유지할 수 있음
*   필요한 정보를 가진 객체들로 책임이 분산되기 때문에 더 응집력 있고

    이해하기 쉬워짐
* 따라서 높은 응집도 가능 → 결과적으로 결합도가 낮아져서 간결하고 유지보수하기 쉬운 시스템 구축

> 객체가 정보를 알고 있다고 그 정보를 저장하고 있을 필요는 없다.

*   객체는 해당 정보를 제공할 수 있는 다른 객체를 알고 있거나

    필요한 정보를 계산해서 제공할 수 있음
* 어떤 방식이건 정보 전문가가 데이터를 반드시 저장하고 있을 필요는 없다는 사실을 인지

#### 예매하라는 메시지

* 외부의 인터페이스가 아닌 내부의 구현

> 책임을 수행하는 데 필요한 작업을 구상해보고 스스로 처리할 수 없는 작업이 무엇인지를 가릴 수준

> 만약 스스로 처리할 수 없는 작업이 있다면 → 외부에 도움을 요청해야 함

* 외부로 전송해야 하는 새로운 메시지가 되고 → 최종적으로 이 메시지가 새로운 객체의 책임으로 할당
* 이 같은 연쇄적인 메시지 전송과 수신을 통해 `협력 공동체`가 구성되는 것임

### 높은 응집도와 낮은 결합도

> 동일한 기능을 구현할 수 있는 무수히 많은 설계가 존재함

> DiscountConidtion이 왜 Movie와 협력하는 방법을 택했을까?

* 응집도와 결합도에 정답이 존재함
* 높은 응집도와 낮은 결합도는 객체에 책임을 할당할 때 항상 고려해야 한느 기본 원리

> 책임을 할당할 수 있는 다양한 객체들이 존재한다면 응집도와 결합도의 측면에서 더 나은 대안을 선택하는 것이 좋음

```jsx
LOW COUPLING 패턴

어떻게 하면 의존성을 낮추고 변화의 영향을 줄이며 재사용성을 증가시킬 수 있을까?

- 설계의 전체적인 결합도가 낮게 유지되도록 책임을 할당하기

- 낮은 결합도는 모든 설계 결정에서 염두에 둬야 하는 원리
- 다시 말해 설계 결정을 평가할 때 작용할 수 있는 평가 원리
```

❄️ 얼마나 새로운 결합도가 추가되나?

```jsx
HIGH COHESION 패턴

어떻게 복잡성을 관리할 수 있는 수준으로 유지할 것인가? 
높은 응집도를 유지할 수 있게 책임을 할당하기

- 낮은 결합도처럼 높은 응집도도 모든 설계 결정에서 염두해야 할 평가 원리
```

❄️ 요금을 계산하는 방식이 변경될 경우 → Screening도 함께 변경 서로 다른 이유로 변경되는 책임을 짐ㄹ어짐 → 응집도가 낮아짐

### 창조자에게 객체 생성 책임을 할당하라

> 영화 예매 협력의 최종 결과물 → Reservation 인스턴스를 생성하는 것

* 이것은 협력에 참여하는 객체에게 Reservation 인스턴스를 생성할 책임을 할당해야 한다는 것을 의미
* CREATOR 패턴은 이 같은 경우에 사용할 수 있는 책임 할당 패턴으로 객체를 생성할 책임을 어떤 객체에게 할당할지에 대한 지침을 제공함

```jsx
CREATOR 패턴

객체 A를 생성할 때 어떤 객체에게 객체 생성 책임을 할당해야 하는가?

- 아래 조건을 최대한 많이 만족하는 B에게 객체 생성 책임을 할당

1. B가 A객체를 포함하거나 참조한다.

2. B가 A객체를 기록한다.

3. B가 A객체를 긴밀하게 사용한다.

4. B가 A객체를 초기화하는 데 필요한 데이터를 가지고 있다.

- 의도 
	어떤 방식으로든 생성되는 객체와 연결되거나 관련될 필요가 있는 객체에 
	해당 객체를 생성할 책임을 맡기는 것임
	생성될 객체에 대해 알고 있어야 하거나
	그 객체를 사용해야 하는 객체는 어떤 방식으로든 생성될 객체와 연결될 것임
	다시 말해 두 객체는 서로 결합

- 이미 결합돼 있는 객체에 생성 책임을 할당하는 것은 
	설계의 전체적인 결합도에 영향을 미치지 않음
	결과적으로 CREATOR 패턴은 이미 존재하는 객체이용 -> ㅓㄹ계가 낮은 결합도
```

> 현재까지의 책임 분배는 설계를 시작하기 위한 대략적인 스케치에 불과함

* 실제 설계 : 코드를 작성하는 동안 이뤄짐
* 협력과 책임이 제대로 동작하는지 확인할 수 잇는 유일한 방법
  * 코드를 작성하고 실행하기

## 3. 구현을 통한 검증

```java
private Money calculateFee(int audienceCount) {
	return movie.calcaulateMovieFee(this).times(audienceCount);
}
```

> Movie에 전송하는 메시지의 시그니처 : calculateMovieFee(Screening screening)

* 이 메시지는 수신자인 Movie가 아닌 송신자인 Screening의 의도를 표현
* Movie 내부 구현에 대한 어떤 지식도 없이 전송할 메시지를 결정 했다는 것
* → 이는 내부 구현을 깔끔하게 캡슐화 가능함

❄️ 유일한 연결고리는 메시지 뿐인 것을 잊지 않기 - 결합도를 느슨하게 유지할 수 있다는 장점 - 캡슐화와 낮은 결합도라는 목표를 손쉽게 달성할 수 있음

```java
public class Movie {
	public Money calculateMovieFee(Screening screening) {}
}
```

> 요금을 계산하기 위해 → Movie는 기본 금액(fee), 할인 조건(discountConditions)

* 할인 정책의 정보등을 알아야 함
* 할인 정책을 Movie의 일부로 구현하고 있기 때문에 → 이들을 인스턴스 변수로 선언

### DiscountCondition 개선하기

> 가장 큰 문제점 : 변경에 취약한 클래스를 가짐

* 변경에 취약한 클래스 : 코드를 수정해야 하는 이유를 하나 이상 가지는 클래스
* 현재의 코드에서 변경의 이유가 다양한 클래스?

```java
- 새로운 할인 조건 추가
	- if ~ else 구문을 수정
	- 새로운 할인 조건이 새로운 데이터 요청 -> 속성을 추가도 해야함

- 순번 조건을 판단하는 로직 변경

- 기간 조건을 판단하는 로직이 변경되는 경우
```

#### 코드를 통해 변경의 이유를 파악하기

❄️ 인스턴스 변수가 초기화 되는 시점

* 응집도가 높은 클래스는 인스턴스를 생성할 때 모든 속성을 함께 초기화
* 응집도가 낮은 클래스는 객체의 속성 중 일부만 초기화 → 일부는 초기화되지 않는 상태로 남겨진

❄️ 함께 초기화되는 속성을 기준으로 코드를 분리하기

* 서로 다른 시점에 초기화되거나 일부만 초기화된다는 것은 응집도가 낮음

❄️ 메서드들이 인스턴스 변수를 사용하는 방식을 살펴보기

* 모든 메서드가 객체의 모든 속성을 사용 → 클래스의 응집도가 높음
* 반면 메서드를 사용하는 속성에 따라 그룹이 나뉨 → 클래스의 응집도가 낮음

> 속성 그룹과 해당 그룹에 접근하는 메서드 그룹을 기준으로 코드를 분리하라

```java
클래스 응집도 판단하기

1. 클래스가 하나 이상의 이유로 변경이 됨? 응집도 낮음 -> 변경의 이유를 기준으로 클래스 분리
2. 클래스의 인스턴스 초기화 시점에 따라 서로 다른 속성 초기화? 응집도 낮음
	 - 초기화되는 속성의 그룹을 기준으로 클래스를 분리
3. 메서드 그룹이 속성 그룹을 사용하는지 여부로 나뉨? -> 이를 그룹을 기준으로 클래스를 분리
```

### 타입 분리하기

응집도가 높아졌지만 변경과 캡슐화하라는 관점에 보면 전체적으로 설계의 품질이 나빠지고만 것

### 다형성을 통해 분리하기

> 둘 모두 할인 여부를 판단하는 동일한 책임을 판단하기 위해 사용되는 방법이 서로 다르다른 사실은
>
> Movie에게 중요하지 않음
>
> 결국 그냥 계산만 해줘!

🌈 역할의 개념이 등장

* Movie의 입장에서 동일한 책임을 수행한다 → 동일한 역할을 수행한다.
* 역할은 협력 안에서 대체 가능성을 의미함
  * 역할의 개념을 이용하면 → 구체적인 클래스를 모르더라도
  * 오직 역할에 대해서만 결합되도록 의존성을 제한

> 역할을 사용하면 객체의 구체적인 타입을 추상화가 가능함

* 자바에서는 일반적으로 역할을 구현하기 위해 → 추상 클래스, 인터페이스를 사용
* 역할을 대체할 클래스 사이에서 구현을 공유? → 추상클래스
* 구현을 공유할 필요없이 역할을 대체하는 객체들의 책임만 정의? → 인터페이스

🌈 예시를 보여줘

```java
public interface DiscountCondition {
	boolean isSatisfiedBy(Screening screening);
}
```

> SequenceCondition과 PeriodCondition의 인스턴스가 DiscountCondition 인터페이스를 실체화 하도록 수정

```java
public class PeriodCondtion implements DiscountCondition {...}

public class SequenceCondtion implements DiscountCondtion {...}
```

🌈 협력하는 구체적인 타입을 몰라도 됨! 협력하는 객체가 DiscountCondition 역할을 수행하고 isSatisfiedBy 메시지를 이애할 수 있다는 사실만 알고 있어도 충분함

> 객체의 암시적인 타입에 따라 행동을 분기해야 한다면 암시적인 타입을 명시적인 클래스로 정의하고
>
> 행동을 나눔으로써 응집도 문제를 해결할 수 잇음 객체의 타입에 따라 변하는 행동이 있다면 → 타입을 분리하고
>
> 변화하는 행동을 각 타입의 책임으로 할당하라는 것임 이를 POLYMORPHISM(다형성) 패턴

```jsx
POLYMORPHISM

객체의 타입에 따라 변하는 로직이 있을 때 변하는 로직을 담당할 책임을 어떻게 할당할까?
- 타입을 명시적으로 정의하고 -> 다형적으로 행동하는 책임을 할당하기

- 조건에 따른 변화는 프로그램의 기본 논리임

- POLYMORPHISM 패턴은 객체의 타입을 검사해서 타입에 따라 여러 대안들이 수행하는 논리
	사용하지 말라고 경고함
- 대신 다형성을 이용해 새로운 변화를 다루기 쉽게 확장하라
```

### 변경으로부터 보호하기

* 위의 예제는 서로 다른 이유로 변경된다는 수정됨
  * 순번 조건의 구현 방법이 변경되는 경우
  * 기간 조건의 구현 방법이 변경될 경우
* 새로운 할인 조건이 추가된다면?
  * 오직 인터페이스를 실체화하는 클래스를 추가하는 것
* 변경을 캡슐화하도록 책임을 할당하는 것 → 변경 보호 패턴(PROTECTED VARIATIONS)

```jsx
PROTECTED VARIATIONS

어떻게 설계해야 변화와 불안정성이 다른 요소에 영향을 미치지 않도록 할 수 있을까?
- 변화가 예상되는 불안정한 지점들을 식별하고
- 그 주위에 안정된 인터페이스를 형성하도록 책임을 할당

PROTECTED VARIATIONS : 책임 할당 관점에서 캡슐화를 설명한 것
-- 설계에서 변화하는 것이 무엇인지 고려하고 변하는 개념을 캡슐화 하기 --
// 우리가 캡슐화해야 하는 것은 변경
- 변경이 될 가능성이 높은가? -> 캡슐화
```

> 클래스를 변경에 따라 분리하고 인터페이스를 이용해 변경을 캡슐화 한다는 것

* 설계의 결합도와 응집도를 향상시키는 매우 강력한 방법
* 하나의 클래스가 여러 타입의 행동을 구현
  * 이를 분리하고 POLYMORPHISM 패턴에 따라 책임을 분산
* PROTECTED VARIATIONS 패턴에 따라 안정적인 인터페이스로 변경을 캡슐화

### 변경과 유연성

* 설계를 주도하는 것은 변경임

💡 아는데 어떻게 해요

1. 코드를 이해하고 수정하고 쉽고 최대한 단순하게 설계
2. 코드를 수정하지 않고도 변경을 수용할 수 있도록 코드를 더 유연하게 만들기

> 요구사항의 추가

* 상속은 너무 변경 사항이 많음 → Props Drilling
* 합성을 이용하기
  * Movie에 합성을 시키면 유연한 설계가 완성

💡 유연성에 대한 압박이 설계에 미치는 영향

* 유연성은 의존성 관리의 문제임
* 요소들 사이의 의존성 정도가 유연성의 정도를 결정함
* 유연성의 정도에 따라 결합도를 조절할 수 있는 능력을 갖추는 것

## 4. 책임 주도 설계의 대안

💡 현실과 이상의 벽은 높다

* 책임 주도 설계에 익숙해지는 것은 부단한 노력과 시간이 필요함
* 설계를 진행하는 동안 데이터가 아닌 책임 관점에서 사고하기 위해서는 충분한 경험과 학습이 피요함

> 최대한 빠르게 목적한 기능을 수행하는 코드를 작성하는 것임

* 아무것도 없는 상태에서는 아무것도 이룰 수 없음

### 메서드 응집도

1. 어떤 일을 수행하는지 한눈에 파악하기 어렵기 때문에 코드를 전체적으로 이해하는 데 너무 많은 시간이 걸림
2. 하나의 메서드 안에서 너무 많은 작업을 처리 → 변경이 필요할 때 수정할 부분을 찾기 힘듬
3. 메서드 내부의 일부 로직만 수정해도 → 다른 로직이 버그가 발생할 확률이 증가함
4. 로직의 일부만 재사용이 불가능함
5. 코드를 재사용하는 유일한 방법은 원하는 코드를 복사해서 붙여넣기 → 중복을 초래

💡 오직 하나의 작업만 수행하고 하나의 변경 이유만 가지는 작고 명확하고 응집도가 높은 메서드로 구성

### 객체를 자율적으로 만들자

> 어떤 메섣르르 어떤 클래스로 이동시켜야 할까?

*   객체가 자율적인 존재여야 한다는 사실을 떠올리면

    쉽게 답할 수 있음
*   자신이 소유하고 있는 데이터를 자기 스스로 처리하도록 만드는 것이

    자율적인 객체를 만드는 지름길임

> 메서드가 사용하고 있는 데이터를 저장하고 있는 클래스로 메서드를 이동시키면 됨
