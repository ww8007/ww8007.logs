# 😆 3. OBJ 역할 책임 협력



## 3. 역할 책임 협력

### 위키

*   책임

    객체에 의해 정의되는 응집도 있는 행위의 집합

    객체가 유지해야 하는 정보와 수행할 수 있는 행동에 대해 개략적으로 서술한 문장

    > 즉 : 객체의 책임은

    1. 객체가 무엇을 알고 있고
    2. 무엇을 할 수 있는가로 구성

    > 하는 것(doing) 아는 것(knowing)
*   책임 주도 설계(Responsibility-Driven Design)

    책임을 찾고 → 책임을 수행할 적절한 객체를 찾아 → 책임을 할당하는 방식으로 협력을 설계
*   데이터-주도 설계(Data-Driven Design)

    * 객체의 내부 구현에 초점을 맞춘 설계 방법
    * 객체지향 프로그래밍에 갓 입문한 사람들이 가장 쉽게 빠지는 실수

    > 객체의 행동이 아닌 → 상태에 초점을 맞추는 것
    >
    > 1. 객체에 필요한 상태가 무엇인지를 결정하고
    > 2. 상태에 필요한 행동을 결정함

    > 이러한 행동들이 객체의 내부 구현이 → 객체의 퍼블릭 인터페이스도 함께 변경되고
    >
    > → 결국 객체에 의존하는 클라이언트로 변경의 영향이 전파
* 역할의 중요점
  * 역할
    * 다양한 종류의 객체를 수용할 수 있는 일종의 슬롯
    * 구체적인 객체들의 타입을 캡슐화하는 추상화
  * 협력 안에서 `역할이 → 어떤 책임을 수행하는지를 결정`하는 것이 중요
    * 구현은 그 다음
    * 객체에게 중요한 것은 행동이며, 역할은 객체를 추상화해서 객체 자체가 아닌 협력에 초점을 맞출 수 있게 함
*   역할 모델링(Role Modeling)

    역할을 설계의 중심 개념으로 바라보는 것

    상호작용하는 객체들의 협력 패턴을 역할들 사이의 → 협력 패턴으로 추상화함으로써

    유연하고 재사용 가능한 시스템을 얻을 수 있는 방법에 관해 잘 설명하고 있음

### 이 장의 목적

♻️ 객체는 협력이 끝나고 협력에서의 역할을 잊고 원래의 객체로 돌아온다.

> 객체지향 패러다임 관점에서 핵심 : 역할, 책임 협력

> 객체지향 본질 : 협력하는 개체들의 공동체를 창조하는 것

* 설계의 핵심
  * 협력을 구성하기 위해 적절한 객체를 찾고
  * 적절한 책임을 할당하는 과정에서 드러남
  * 클래스와 상속의 객체들의 책임과 협력이 어느 정도 자리 잡은 후에 사용 가능한 구현 메커니즘

📌 객체는 여러 역할을 가질 수 있지만 특정한 협력 안에서 → 오직 하나의 역할만이 보여지는 점을 주의 배우도 한 번에 하나의 역할만 수행함

특정한 협력 안에서는 협력에 필요한 객체의 특정한 역활을 제외한 나머지 부분들은 감춰지게 됨

> 역할은 특정한 객체의 종류를 캡슐화하기 때문에 동일한 역할을 수행하고 계약을 준수하는 대체 가능한 객체들은 다형적

### 1. 협력

* 객체지향 시스템 : 자율적인 객체들의 공동체

> 고립된 존재가 아닌 시스템의 기능이라는 더 큰 목표를 달성하기 위한 다른 객체와 협력하는 사회적인 존재

* 협력 자체는 객체가 다른 객체에게 도움을 요청할 때 시작됨

❓ 메시지 전송

* 객체 사이의 협력을 위해 사용할 수 잇는 유일한 커뮤니케이션 수단
*   객체는 다른 객체의 상셍한 내부 구현에 직접 접근이 불가능하기 때문에

    메시지 전송을 통해시먼 자신의 요청을 전달이 가능함

> 메시지를 수신한 객체는 메서드를 실행해 요청에 응답함

❓ 객체를 자율적이게 만드는 것은 어떤 것이 있나요?

> 내부 구현을 캡슐화 하는 것 입니다.

* 캡슐화를 통해 변경에 대한 파급효과를 제한할 수 있기 때문에
* 자율적인 객체는 변경하기도 쉬워짐

### 협력이 설계를 위한 문맥을 결정한다.

> 객체지향은 객체를 중심에 놓는 프로그래밍 패러다임

* 객체란 상태와 행동을 함께 캡슐화 하는 실행 단위

> 상태는 객체가 행동하는 데 필요한 정보에 의해 결정되고

> 행동은 협력 안에서 객체가 처리할 메시지로 결정됨

* 객체가 참여하는 협력이 객체를 구성하는 행동과 상태 모두를 결정함
* 협력은 객체를 설계하는데 필요한 일종의 `문맥(context)`를 제공함

## 책임

### 책임이란 무엇인가

> 객체를 설계하기 위해 필요한 문맥인 협력이 갖춰져 있다고 상상

❓ 다음으로 할 일은 무엇일까?

> 협력에 필요한 행동을 수행할 수 있는 적절한 객체를 찾는 것

* 협력에 참여하기 위해 객체가 수행하는 행동을 `책임`이라고 부름

❓ 책임❓ 하는 것과 아는 것

> 하는 것

* 객체를 생성하거나 계산을 수행하는 등의 스스로 하는 것
* 다른 객체의 행동을 시작시키는 것
* 다른 객체의 활동을 제어하고 조절하는 것

> 아는 것

* 사적인 정보에 관해 아는 것
* 관련된 객체에 관해 아는 것
* 자신이 유도하거나 계산할 수 있는 것에 관해 아는 것

| Screening     |       |
| ------------- | ----- |
| 상영 정보를 알고 있다. | Movie |
| 예매 정보를 생성한다.  |       |

| Movie         |                |
| ------------- | -------------- |
| 영화 정보를 알고 있다. | DiscountPolicy |
| 가격을 계산한다.     |                |

| DiscountPolicy |                   |
| -------------- | ----------------- |
| 할인 정책을 알고 있다.  | DiscountCondition |
| 할인된 가격을 계산한다.  |                   |

> 일반적으로 책임과 메시지의 크기는 다름

*   책임 : 객체가 수행할 수 있는 행동을 종합적이고 간략하게 서술

    메시지보다 추상적이고 개념적으로 더 큼
* 처음에는 단순한 책임 → 여러 메시지로 분할도 가능함

❓ 책임의 관점에서 아는 것과 하는 것이 밀접한 관계를 가지고 있음 객체는 자신이 맡은 역할을 수행하는 데 필요한 정보를 알고 있을 책임이 있음 또한 객체는 자신이 할 수 없는 작업을 도와줄 알고 있을 책임이 있음

> 어떤 책임을 수행하기 위해서 그 책임을 수행하는 데 필요한 정보도 알 책임이 존재함

> 협력이 중요한 이유

* 객체에게 할당한 책임을 결정할 수 있는 문맥을 제공하기 때문
* 적절한 협력이 → 적절한 책임을 제공하고
* 적절한 책임을 → 적절한 객체에게 할당해야만
  * 단순하고 유연한 설계를 창조가 가능함

> 객체지향 설계에서 가장 중요한 것은 책임

* `객체에게 얼마나 적합한 책임을 할당하느냐`
  * 설계의 전체적인 품질을 결정함

> 구현 방법 자체는 책임을 결정한 다음에 고민해도 늦지 않음

### 책임 할당

* 자율적인 객체를 만드는 것 → 책임을 수행하는 데 필요한 정보를 알고 있는 전문가에게 책임을 할당하는 것

> 책임 할당을 위한 INFORMATION EXPERT(정보 전문가 패턴)

❓ 일상과 비슷함 우리가 문제가 생기면 → 그 분야의 전문가에게 상담을 의뢰 객체들 역시 필요한 지식과 방법을 가장 잘 알고 있는 객체에게 도움을 요청함 요청에 응답하기 위해 필요한 이 행동이 → 객체가 수행할 책임

> 객체에게 책임을 할당하기 위해서 먼저 `협력이라는 문맥을 정의`

> 협력을 설계하는 것

*   출발점 : 시스템이 사용자에게 제공하는 기능을

    시스템이 담당할 하나의 책임으로 바라보는 것
*   객체지향 설계 :

    시스템의 책임을 완료하는 데 필요한 → 더 작은 책임을 찾아내고

    이를 객체들에게 할당하는 반복적인 과정을 통해 모양을 갖춰감

❓ 객체지향적 설계를 한다는 것 - 시스템의 책임을 완료한는 데 필요한 더 작은 책임을 찾아내고

* 이를 객체들에게 할당하는 반복적인 과정
* 영화 예매 시스템
  1.  예매하라

      *   메시지 선택 했으니 → 적절한 객체를 선택

          영화를 예매하는 책임을 어떤 객체에게 할당해야 할까?

      💡 기본 전략 : 정보 전문가에게 책임을 할당하자
  2. 예매하라 → :Screening
  3. 영화를 예매하기 위해서는 예매 가격을 계산해야 함

> 객체지향 설계는 협력에 필요한 메시지를 찾고

* 메시지에 적절한 객체를 선택하는 반복적인 과정을 통해 이뤄짐
* 이런 메시지가 메시지를 수신할 객체의 책임을 결정함

💡 말만 들어서는 되게 쉬워보이는데요?

*   어떤 경우에는 응집도와 결합도의 관점에서

    정보 전문가가 아닌 → 다른 객체에게 책임을 할당하는 것이 더 적절한 경우도 있음
* But : 기본적인 전략 : 책임을 수행할 정보 전문가를 찾는 것
  * 정보 전문가에게 책임을 할당하는 것만으로도
    * `상태와 행동을 함께 가지는 자율적인 객체를 만들 가능성이 높아짐`

### 책임 주도 설계

> 내용 정리 : 협력을 설계하기 위해서는 → 책임에 초점을 맞춰야 함

💡 책임을 찾고 → 책임을 수행할 적절한 객체를 찾아 책임을 할당하는 방식으로 협력을 설계 책임 주도 설계(Responsibility-Driven Design, RDD)💡 책임 주도 설계 방법의 과정

1. 시스템이 사용자에게 제공해야 하는 기능인 시스템 책임을 파악한다.
2. 시스템 책임을 더 작은 책임으로 분할한다.
3. 분할된 책임을 수행할 수 있는 적절한 객체 또는 역할을 찾아 책임을 할당한다.
4. 객체가 책임을 수행하는 도중 다른 객체의 도움이 필요한 경우 → 이를 책임질 적절한 객체 또는 역할을 찾는다.
5. 해당 객체 또는 역할에게 책임을 할당함으로써 두 객체가 협력하게 된다.

* 협력은 객체를 설계하기 위한 구체적인 문맥을 제공함
  * 협력이 책임을 이끌어내고 책임이 협력에 참여할 객체를 결정함

💡 책임을 할당할 때 고려해야 하는 두 가지 요소

* [ ] 메시지가 객체를 결정해야 한다.
* [ ] 행동이 상태를 결정해야 한다.

### 메시지가 객체를 결정한다.

> 객체에게 책임을 할당하는 데 필요한 메시지를 먼저 식별하고

* 메시지를 처리할 객체를 나중에 선택하는 것이 중요함

> 객체가 메시지를 선택하는 것이 아닌 → 메시지가 객체를 선택하게 하는 것

💡 WHY?

1. 객체가 최소한의 인터페이스를 가질 수 있게 함

*   필요한 메시지가 식별될 때까지 객체의 퍼블릭 인터페이스에는 어떤 것도 추가하지 않음

    객체는 애플리케이션에 크지도, 작지도 않은 꼭 필요한 크기의 퍼블릭 인터페이스를 가질 수 있음

1. 객체는 충분히 추상적인 인터페이스를 가질 수 있게 됨

> 객체의 인터페이스
>
> 무엇(what)을 하는지를 표현해야 하지만
>
> 어떻게(how) 수행하는지를 노출해서는 안됨

> 메시지는 외부의 객체가 요청하는 무언가를 의미하기 때문에

* 메시지를 먼저 식별하면 무엇을 수행할지에 초점을 맞추는 인터페이스를 얻을 수 있음

> 영화 예매 시스템의 경우 예매하라라는 메시지를 선택하는 것으로 설계를 시작함에 초점

* 협력을 위해 예매하라 → 메시지를 수신할 적절한 객체로 Screening
*   결과적으로 협력을 구성하는 객체들의 인터페이스는

    `충분히 추상적인 동시`에 `최소한의 크기를 유지`
*   객체가 충분히 추상적이면서 → 미니멀리즘을 따르는 인터페이스를 가지게 하고 싶다면

    > 메시지가 객체를 선택하도록!

### 행동이 상태를 결정한다.

> 객체가 존재하는 이유 : 협력에 참여하기 위함

* 객체는 협력에 필요한 행동을 제공해야 함

💡 객체의 행동 : 객체가 협력에 참여할 수 있는 유일한 방법 객체가 협력에 적합한지를 결정하는 것 : 객체의 상태가 아닌 행동

> 얼마나 적절한 객체를 창조했냐?

* [ ] 얼마나 적절한 책임을 할당 했는가?

> 얼마나 책임이 절절한가?

* [ ] 협력에 얼마나 적절한가?
* [ ] 객체지향 프로그래밍에 갓 입문한 사람들이 가장 쉽게 빠지는 실수

> 객체의 행동이 아닌 → 상태에 초점을 맞추는 것
>
> 1. 객체에 필요한 상태가 무엇인지를 결정하고
> 2. 상태에 필요한 행동을 결정함

> 이러한 행동들이 객체의 내부 구현이 → 객체의 퍼블릭 인터페이스도 함께 변경되고
>
> → 결국 객체에 의존하는 클라이언트로 변경의 영향이 전파

❓ 어떻게 하는게 좋나요?

> 캡슐화를 위반하지 않도록 구현에 대한 결정을 뒤로 미루면서 객체의 행위를 고려하기 위해서는
>
> 항상 협력이라는 문맥 안에서 객체를 생각해야 합니다. 협력 관계 속에서
>
> 1. 다른 객체에에게 무엇을 제공해야 하고
> 2. 다른 객체로부터 무엇을 얻어야 할지 고민해야만 훌륭한 책임을 수확할 수 있음

* 개별 객체의 상태와 행동이 아닌 → 시스템의 기능을 구현하기 위한 협력에 초점을 맞춰야지만 응집도가 높고 결합도가 낮은 객체를 창조할 수 있음
* 상태 : 단지 객체가 행동을 정상적으로 수행하기 위해 필요한 재료

> 중요한 것 객체의 상태가 아니라 행동임 행동이 중요 : 객체가 가질 수 있는 상태는 행동을 결정하고 나서야 비로소 결정할 수 있음 협력이 객체의 행동을 결정하고 행동이 상태를 결정해야 함 행동이 바로 → 객체의 책임

## 3. 역할

### 역할과 협력

> 객체는 협력이라는 주어진 문맥 안에서 특정한 목적을 갖게 됨

> 객체의 목적 : 협력 안에서 객체가 맡게 되는 책임의 집합으로 표시

* 객체가 어떤 특정한 협력 안에서 수행하는 책임의 집합을 → 역할
* 실제로 모델링을 할 때 → 특정한 객체가 아닌 → 역할에게 책임을 할당한다로 이해
* 영화 예매 협력
  * 예매하라
    * 적합한 객체로 Screening

하나의 단계처럼 보이는 이 책임 할당 과정

> 실제로는 두 개의 독립적인 단계가 합쳐진 것

1. 단계는 영화를 예매할 수 있는 적절한 역할이 무엇인가?
2. 역할을 수행할 객체로 → Screening 인스턴스를 선택하는 것

> 역할에 특별한 이름을 부여하지는 않았지만 → 실제로

* 익명의 역할을 찾고
* 그 역할을 수행할 수 있는 객체를 선택하는 방식으로 설계가 진행

### 유연하고 재사용 가능한 협력

> 역할이 중요한 이유 : 역할을 통해 유연하고 재사용 가능한 협력을 얻을 수 있기 때문

*   이해를 돕기 위해 역할이라는 개념을 고려하지 않고

    객체에게 책임을 할당 한다고 가정

1. 예매하라 → : Screening → 2. 가격을 계산하라 → :Movie → 3. 할인 요금을 계산하라

*   문제점

    영화 예매 도메인 : 금액 할인 정책, 비율 할인 정책이라는 두 가지 종류의 가격 할인 정책이 존재함

    AmountsDiscountPolicy, PercentDiscountPolicy 인스턴스라는 두 가지 종류의 객체가

    → 할인 요금을 계산하라는 메시지에 응답할 수 잇어야 함

    > 그러면 두 종류의 객체가 참여하는 협력을 개별적으로 만들어야 하나?

    → NO

    * 이러면 → 코드가 중복되고 말것임
      * 두개 모두 → 할인 요금 계산리알는 동일한 책임을 수행함
      *   객체라는 존재를 지우고 → 할인 요금을 계산하라는 메시지에 응답할 수 잇는 대표자를 생각 한다면

          두 협력을 하나로 통합할 수 있을 것임

          이 대표자를 협력 안에서 두 종류의 객체를 교대로 바꿔 끼울 수 있는 일종의 슬롯으로 생각할 수 있음

> 그러면 두 종류의 객체가 참여하는 협력을 개별적으로 만들어야 하나?

→ NO

* 이러면 → 코드가 중복되고 말것임
  * 두개 모두 → 할인 요금 계산리알는 동일한 책임을 수행함
  *   객체라는 존재를 지우고 → 할인 요금을 계산하라는 메시지에 응답할 수 잇는 대표자를 생각 한다면

      두 협력을 하나로 통합할 수 있을 것임

      이 대표자를 `협력 안에서 두 종류의 객체를 교대로 바꿔 끼울 수 있는 일종의 슬롯으로 생각할 수 있음`

> 프로그래밍은에서 코드의 중복은 모든 문제의 근원이다.

> 문제를 해결하기 위해서는 → 객체가 아닌 책임에 초점

#### 역할은 다른 것으로 교체할 수 있는 책임의 집합

* 역할이 두 종류의 구체적인 객체를 포괄하는 추상화라는 점에 주목하라.
  * 따라서 Amount DiscountPolicy와 PercentDiscountPolicy를 포괄할 수 있는 추상적인 이름을 부여

> 고로 DiscountPolicy가 어떨까?

* 요점은 동일한 책임을 수행하는 역할을 기반으로 두 개의 협력을 하나로 통합할 수 있다는 것
  * 역할을 이용하면 불필요한 중복 코드를 제거할 수 있음
  * 더 조흔 소식 : 협력이 더 유연해졌다는 점
* 책임과 역할을 중심으로 협력을 바라보는 것 → 변경과 확장이 용이한 유연한 설계로 나아가는 첫걸음

❓ 역할의 구현은 어떻게 하나요?

> 역할을 구현하는 가장 일반적인 방법 : 추상 클래스, 인터페이스를 사용하는 것
>
> 협력의 관점
>
> * 인터페이스, 추상 클래스 → 구체 클래스가 따라야 하는 책임의 집합을 서술한 것
> * 추상 클래스 : 책임의 일부를 구현해 놓은 것
> * 인터페이스 : 일체의 구현 없이 책임의 집합을 나열
>
> → 둘 모두 역할을 정의할 수 잇는 구현 방법이라는 공통점을 공유함

> 왜 영화 예매 시스템에서는 DiscountPolicy를 추상 클래스로 구현 했을까?

* 역할을 수행할 수 있는 모든 객체들이 공유하는 상태와 행동의 기본 구현이 존재하기 때문

> 그럼 DiscountCondition?

* 공통의 구현이 필요없고 단지 책임의 목록만 정의하면 되기 때문에 → 인터페이스

> 추상 클래스와 인터페이스는 동일한 책임을 수행하는
>
> 다양한 종류의 클래스들을 협력에 참여시킬 수 있는 확장 포인트를 제공함
>
> 이들은 동일한 책임을 수행할 수 있는 객체들을 협력 안에서 수용할 수 있는 역할

* 중요점
  * 역할
    * 다양한 종류의 객체를 수용할 수 있는 일종의 슬롯
    * 구체적인 객체들의 타입을 캡슐화하는 추상화
  * 협력 안에서 `역할이 → 어떤 책임을 수행하는지를 결정`하는 것이 중요
    * 구현은 그 다음
    * 객체에게 중요한 것은 행동이며, 역할은 객체를 추상화해서 객체 자체가 아닌 협력에 초점을 맞출 수 있게 함

> 기술적 매커니즘이 모여 → 유연하고 재사용 가능한 협력을 만들 수 잇는 기반을 제공한다.

### 객체 대 역할

> 역할 : 객체가 참여할 수 있는 일종의 슬롯

* 유용하고 재사용 가능한 설계라는 문맥
  * 역할의 중요성은 아무리 강조해도 지나치지 않음

❓ 오직 한 종류의 객체만 협력에 참여하는 상황에서 역할이라는 개념을 고려하는 것이 유용할까? 역할이라는 개념을 생략하고 → 적접 객체를 이용해 협력을 설계하는 것이 더 좋지 않을까? 이런 경우에는 역할을 사용하는 것이 상황을 오히려 복잡하게 만드는 것이 아닐까?

> 객체에 관해 생각할 때 “이 객체가 무슨 역할을 수행해야 하는가?”라고 자문하는 것이 도움됨

* 질문
  * 객체가 어떤 형태를 띠어야 하는지
  * 어떤 동작을 해야하는지에 집중할 수 있게 도와줌

> 동일한 종류의 객체가 하나의 역할을 항상 수행한다면 → 둘은 동일한 것

하지만 어떤 협력에서 하나 이상의 객체가 동일한 책임을 수행할 수 있다면

역할은 서로 다른 방법으로 실행할 수 있는 책임의 집합

> 역할은 프로그램이 실행될 때 기계 장치에서 적절한 객체로 매워 넣을 수 있는 하나의 슬롯
>
> 배우가 극중에서 믿을 수 있는 배역을 배역을 맡아서 하려는 것처럼 객체는 의미 있는 역할을 정의하는 책임을 통해 → 애플리케이션의 기능을 담당함

💡 협력에 적합한 책임을 수행하는 대상이 한 종류라면 간단하게 객체로 간주 여러 종류의 객체들이 참여할 수 있다면 → 역할

> 역할을 가리켜 실행되는 동안 협력 안에서 각자의 위치를 가지는 객체들에 대한 별칭

* 협력 : 역할들의 상호작용으로 구성되고
* 협력을 구성하기 위해 → 적합한 객체가 선택되며
* 객체는 클래스를 이용해 구현되고 생성

협력 → 역할 → 객체 → 클래스

💡 하지만 현실과 이상은 다름

* 어떤 것이 역할이고, 어떤 것이 객체인지가 또렷하게 드러나지는 않을 것

> 특히나 명확한 기준을 세우기 어렵고 정보가 부족한 초반에는 결정을 내리기 어려울 것임

* 도메인 모델 안에는 개념과 객체와 역할이 어지럽게 뒤섞여 있음
* 이것은 사람들이 세계를 바라보는 일반적인 관점
* 사람 : 세상을 이할 때 무의식적으로 개념, 객체, 역할읠 뒤섞음
*   도메인 모델 : 불완전한 사람들이 사람들이 세상을 바라보는 모델에 기반하기 때문에

    그 역시 동일한 불완전성을 가질 수 밖에 없음

> 설계 초반에는 적절한 책임과 협력의 큰 그림을 탐색하는 것이 가장 중요한 목표여야 함
>
> 역할과 객체를 명확하게 구분하는 것은 그렇게 중요하지 않음
>
> * 단순하게 객체로 시작하고 → 반복적으로 책임과 협력을 정제해가면서 → 필요한 순간에 객체로부터 역할을 분리하자

💡 중요한 것은 책임이다.

> 설계 초반에 다루는 대부분의 대상 : 후보로 취급하는 것이 합리적

* 이는 객체, 역할, 클래스 → 그러나 초반 단계에서 중요하지 않음
* 협력을 위해 어떤 책임이 필요한지를 이해하는 것
* 후보는 식별한 책임을 구분해서 담을 수 있는 일종의 빈자리로서 역할을 수행하는 것으로 충분함
* 동일한 책임을 서로 다른 방식으로 수행할 수 있는 객체들이 필요해질 때가 왔을 때 역활의 도입을 고려해도 늦지 않음

💡 좋은 설게를 가져 간다는 것

*   [ ] 다양한 객체들이 협력에 참여한다는 것이 확실하다면

    역할로 시작하라
*   [ ] 모든 것이 안개 속에 둘러쌓여 있고 정확한 결정이 내리기 어렵다 → 구체적인 객체

    → 다양한 시나리오를 탐색하고 유사한 협력들이 단순화하고 합치다 보면 → 자연스럽게 역할이 모습을 드러냄

> 역할 자체는 객체, 클래스에 비해 잘 알려지지도 구현할 방법도 쉽지 않음 그럼에도 유연하고 확장 가능하며 일관된 구조를 가지는 시스템 구축에 역할은 매우 중요하다.

> 중요한 것은 협력을 구체적인 객체가 아닌 추상적인 역할의 관점에서 설계하면 → 협력이 유연하고 재사용 가능해짐

> 따라서 역할의 가장 큰 장점은 설계의 구성 요소를 추상화할 수 있다는 것이다.

### 역할과 추상화

> 추상화를 이용한 설계의 장점

1. 추상화 계층만을 이용하면 중요한 정책을 상위 수준에서 단순화할 수 있다는 것
2. 설계가 좀 더 유연해지는 것

> 역할은 공통의 책임을 바탕으로 객체의 종류를 숨기기 때문에 이런 관점에서 역할을 객체의 추상화라고 볼 수 있음

* 추상화가 가지는 두 가지 장점은 협력의 관점에서 역할에도 동일하게 적용될 수 있음

#### 추상화의 장점

1. 세부 사항에 억눌리지 않고도 상위 수준의 정책을 쉽고 간단하게 표현할 수 있음
   * 추상화를 적절하게 사용하면
     1. 불필요한 세부 사항을 생략하고
     2. 핵심적인 개념을 강조할 수 있음

*   Example

    예매 요금을 계산하는 데 필요한 할인 정책과 할인 조건의 구조를 표현

    *   금액 할인정책을

        * 순번 조건
        * 기간 고건

        조합해서 다양한 방식의 요금 계산 규칙을 설정할 수 잇는 것

    영화 예매 시스템에 존재하는 할인 정책과 할인 조건의 종류를 파악하기 위한 목적에는 적합

    > But 할인 정책과 할인 조건의 종류라는 너무 세부적인 사항 → 객체들 사이의 핵심적인 관계와 관련된 큰 그림을 파악하는 것을 방해함

> 협력이라는 관점에서는 세부적인 사항은 무시하고 추상화에 집중하는 것이 유용함

* 요금 계산에서 세부 사항 : `할인 정책과 할인 조건의 종류`
* 추상화 : 할인 정책과 할인 조건이 조합되어 → 영화 예매 요금을 결정한다는 사실
* 세부 사항을 무시하고 자체만 바라보면 → 상황을 추상화가 가능함

> 구체적인 할인 정책의 종류를 추상화한
>
> DiscountPolicy와
>
> 상세한 라인 조건의 종류를 추상화한
>
> DiscountCondition을 이용하여 → 협력을 표현 한다면
>
> 객체 사이의 핵심적인 상호작용이 좀 더 또렷하게 드러남

> 협력에 참여하는 할인 정책과 할인 조건의 조율는 중요하지 않음

* 상위 수준에서 협력을 설명이 가능함!

❓ 상위 수준에서 협력을 설명하는 가지는 이점

> 구체적인 객체들이 가지는 복잡성을 제거하고 단순화해서 표현할 수 있음
>
> 구체적인 객체로 대체 가능한 DiscountPolicy와 DiscountCondition이 바로 역할

* [ ] 객체에서 중요한 것 : 행동

> 역할이 중요한 이유

* [ ] 동일한 협력을 수행하는 객체들을 추상화 가능함

> 역할 사용의 이점

* [x] 가격 할인 정책과 함께 2개의 순번 규칙과 1개의 비율 규칙을 적용한다
* [ ] 할인 정책과 여러 개의 할인 조건을 적용한다.

> 협력 안에서 역할이라는 추상화를 이용하면 → 기존 코드를 수정하지 않고도 새로운 행동을 추가가 가능함

* 결과적으로 앞으로 추가될 미지의 정책을 수용이 가능함

🔥 프레임워크나 디자인 패턴과 같이 재사용 가능한 설계 아이디어를 구성하는 핵심적인 요소 : 역할

### 배우와 배역

> 연극에 참여하는 그 순간만큼은 배우들은 사라지면 배역만 남음

* 무대의 막이 내리면 배역은 사라지고 다시 본래의 연극 배우로 돌아옴
* 배우는 연극이 상영되는 짧은 시간 동안에만 자신이 연기해야 하는 배역의 가면을 쓴다.

📖 연극과 배역과 배우 간의 관계

* 배역 : 연극 배우가 특정 연극에서 연기하는 역할
* 배역 : 연극이 상영되는 동안에만 존재하는 일시적인 개념
* 연극이 끝나면 연극 배우는 배역이라는 역할을 벗어던지고 → 원래의 배우로 돌아온다.
* 서로 다른 배우들이 동일한 배역을 연기할 수 있다.
* 하나의 배우가 당양한 연극 안에서 서로 다른 배역을 연기할 수 있따.

> 연극 안에서 배역을 연기하는 배우라는 은유

*   협력 안에서 역할을 수행하는 객체라는 관점이 가진

    입체적인 측면들을 휼륭하게 담아냄
*   객체는 협력이라는 실행 문맥 안에서 특정한 역할을 수행함

    연극 배우는 연극이 끝나면 → 자신의 역할로 돌아옴

♻️ 객체는 협력이 끝나고 협력에서의 역할을 잊고 원래의 객체로 돌아온다.

> 협력이라는 문맥 안에서의 역할 : 특정한 협력에 참여해서 책임을 수행하는 객체의 일부

* 역할 : 객체가 잠시 동안에만 존재하는 일시적인 개념
* 역할은 모양이나 구조에 의해

> 상상을 실현하는 개발자

> 상상을 믿는 개발자

> 하나의 배역을 여러 배우가 연기할 수 있듯이
>
> 동일한 역할을 수행하는 객체들은 서로 대체 가능하다는 것을 의미함

📌 객체는 여러 역할을 가질 수 있지만 특정한 협력 안에서 → 오직 하나의 역할만이 보여지는 점을 주의 배우도 한 번에 하나의 역할만 수행함

특정한 협력 안에서는 협력에 필요한 객체의 특정한 역활을 제외한 나머지 부분들은 감춰지게 됨

> 역할은 특정한 객체의 종류를 캡슐화하기 때문에 동일한 역할을 수행하고 계약을 준수하는 대체 가능한 객체들은 다형적
