# 4. OBJ 설계 품질과 트레이드 오프



## 4. 설계 품질과 트레이드 오프

### 위키&#x20;

<details>

<summary>응집도</summary>

모듈에 포함된 내부 요소들이 연관돼 있는 정도를 나타냄

모듈 내의 요소들이 하나의 목적을 위해 긴밀하게 협력 → 모듈은 높은 응집도를 가짐

모듈 내의 요소들이 서로 다른 목적 추구 → 낮은 응집도

객체지향 관점에서 응집도 → 객체 또는 클래스에 얼마나 관련 높은 책임들을 할당했는지를 나타냄

</details>

<details>

<summary>결합도</summary>

의존성의 정도를 나타내며 다른 모듈에 대해 얼마나 많은 지식을 갖고 있는지를 나타내는 척도

어떤 모듈이 다른 모듈에 대해 너무 자세한 부분까지 알고 있따면 두 모듈 : 높은 결합도

어떤 모듈이 다른 모듈에 대해 꼭 필요한 부분만 → 낮은 결합도

* 객체지향 관점에서 결합도 : 객체 또는 클래스가 협력에 필요한 적절한 수준의 관계만을 유지하고 있는가?

</details>



### 중요 Point

1. 어떤 데이터를 관리해야 하나?
2. 이 데이터에 대해 수행할 수 있는 행동이 무엇인가?

### 들어가면서

> 객체지향 설계의 핵심 : 역할, 책임, 협력

* 협력 : 애플리케이션의 기능을 구현하기 위해 메시지를 주고받는 객체들 사이의 상호작용
* 책임 : 객체가 다른 객체와 협력하기 위해 수행하는 행동
* 역할 : 대체 가능한 책임의 집합

> 객체지향 설계

* 올바른 객체에게 올바른 책임을 할당하면서
  * 낮은 결합도와 높은 응집도를 가진 구조를 창조하는 활동
* 이 정의 : 객체지향 설계의 두 가지 관점

1. 객체지향 설계의 핵심 : 책임
2. 책임을 할당하는 작업 : 응집도와 결합도 같은 설계 품질과 깊이 연관

* 설계 : 변경을 위해 존재하고, 변경에는 어떤 식으로든 비용이 발생함
* 훌륭한 설계 : 합리적인 비용안에서 변경을 수용할 수 있는 구조를 만드는 것
* 적절한 비용 안에서 쉽게 변경 가능한 설계
  * 응집도가 높고
  * 서로 느슨하게 결합돼 있는 요소로 구성

> 결합도와 응집도를 합리적인 수준으로 유지할 수 있는 중요한 원칙

📌 객체의 상태가 아닌 객체의 행동에 초점을 맞출 것

* 객체를 단순한 데이터의 집합으로 바라보는 것 :
  * 객체의 내부구현을 퍼블릭 인터페이스에 노출시키는 결과를 낳음
  * 설계가 변경에 취약해짐
* 객체의 책임에 초점을 맞춘다.
  * 책임은 객체의 상태에서 행동
  * 객체와 객체 사이의 상호작용으로 설계 중심으로 이동시키고
  * 결합도가 낮고, 응집도가 높으며
  * 구현을 효과적으로 캡슐화하는 객체들을 창조할 수 잇는 기반을 제공
* 가끔씩 좋은 설계보다 나쁜 설계를 살펴보는 과정에서 통찰력

## 1. 데이터 중심의 영화 예매 시스템

> 객체지향 설계에는 두 가지 방법을 이용해 시스템을 객체로 분할이 가능함

1. 상태를 분할의 중심축으로
2. 책임을 분할의 중심축으로

* 객체의 상태는 객체가 저장해야 하는 데이터의 집합을 의미
  * 여기서는 상태와 데이터를 동일한 의미로 사용

> 데이터 중심의 관점

* 객체 : 자신이 포함하고 있는 데이터를 조작하고
* 필요한 오펄에ㅣ션을 정의

> 책임 중심의 관점

* 객체 : 다른 객체가 요청할 수 잇는 오퍼레이션을 위해
* 필요한 상태를 보관

> 전자 : 객체를 독립적인 데이터 덩어리

> 후자 : 객체를 협력하는 공동체

❓ 시스템을 분할하기 위해 데이터와 책임중 어떤 것을 초점에 두어야 할까?

> 결론 : 데이터가 아닌 책임에 초점

* 이유는 변경

> 객체의 상태 → 구현에 속함

* 구현은 불안정하기 때문에 변하기 쉬움
* 상태를 객체 분할의 중심축으로 잡으면 구현에 관한 세부사항이 인터페이스에 스며들게 되어
* 캡슐화의 원칙이 무너짐
* 결과적으로 상태 변경 → 인퍼페이스의 변경을 초래함
* 이 인터페이스에 의존하는 모든 객체에게 영향이 퍼지게 됨
* 데이터의 초점을 맞추는 설계 : 변경에 취약함

> 객체의 책임 : 인터페이스에 속함

* 객체는 책임을 드러내는 안정적인 인터페이스 뒤로 책임을 수행하는 데 필요한
* 상태를 캡슐화 → 구현 변경에 대한 파장이 외부로 퍼져 나가는 것을 방지함
* 책임에 초점을 맞추면 → 상대적으로 변경에 안정적인 설계를 얻을 수 있음

#### 데이터를 준비하자

> 데이터 중심 설계 : 객체 내부에 저장되는 데이터를 기반으로 시스템을 분할하는 방법

* 책임 중심 설계 : 책임이 무엇인가를 묻는 것으로 시작한다면
* 데이터 중심 설계 : 객체가 내부에 저장해야 하는 데이터가 무엇인지를 보고 결정

```java
public class Movie {
	private String title;
	private Duration runningTime;
	private Money fee;
	private List<DiscountCondition> discountCondition;

	private MovieType movieType;
	private Money discountAmount;
	private double discountPercent;
}
```

> 데이터 중심의 Movie 클래스 역시

* 책임 중심의 Movie 클래스와 동일하게 인스턴스 변수를 가져감

> 그러나 동일함은 여기까지

❓ 그럼 차이점이 뭔가요?

*   할인 조건 목록(discountCondition)이 인스턴스 변수로

    Movie 안에 직접 포함이 되어있는 점
*   또한 할인 정책을 DiscountPolicy라는 별도의 클래스로 분리했떤 이전 예제와 달리

    금액 할인 정책에 사용되는

    * 할인 금액(discountAmount)과
    * 비율 할인 정책에 사용되는 할인 비용(discountPercent)를 Movie안에서 직접 정의

> 데이터 중심의 설계에서는 객체가 포함해야 하는 데이터에 집중

* 이 객체가 포함해야 하는 데이터는 무엇인가?

> 객체의 책임을 결정하기 전에 이런 질문의 반복에 휩쓸려 있다면 → 데이터 중심의 설계에 매몰

* Movie 클래스 경우 처럼 객체의 종류를 저장하는 인스턴스 변수
  * movieType(인스턴스 변수)
  *   인스턴스의 종류에 따라 배타적으로 사용될 인스턴스 변수(discountAmount, discountPercent)

      함께 포함 시키는 것이 데이터 중심 설계 안에서 → 흔히 볼 수 있는 패턴

## 2. 설계 트레이드 오프

> 데이터 중심 설계 vs 책임 중심 설계 장단점

* 캡슐화
* 응집도
* 결합도

### 캡슐화

> 상태와 행동을 하나의 객체 안에 모은 이유 :

객체의 내부 구현 → 외부로부터 감추기 위해서

*   객체지향이 걍력한 이유 : 한 곳에서 일어난 변경이 전체 시스템에 영향을 끼치지 않도록

    파급효과를 적절하게 조절할 수 있는 장치를 제공하기 때문에

> 객체를 사용하면 변경 가능성이 높은 부분 : 내부에 숨기고

> 상대적으로 안정적인 부분만 공개

* 변경될 가능성이 높은 부분 : 구현
* 상대적으로 안정적인 부분 : 인터페이스라고 부름

> 객체를 설계하기 위한 가장 기본적인 아이디어 : 변경의 정도에 따라 구현과 인터페이스를 분리하고

* 외부에서는 인터페이스에만 의존하도록 관계를 조절하는 것

❓ 객체지향에서 가장 중요한 원리 : 캡슐화

* 외부에서 알 필요가 없는 부분을 감춤으로써 대상을 단순화하는 추상화의 한 종류
* 객체지향 설계의 가장 중요한 원리 : 불안정한 구현 세부사항을 안정적인 인터페이스 뒤로 캡슐화

❓ 복잡성을 다루기 위한 가장 효과적인 도구는 추상화. 다양한 추상화 유형을 사용할 수 있지만 객체지향 프로그래밍에서 복잡성을 취급하는 주요한 추상화 방법: 캡슐화 But : 프로그래밍 시 객체지향 언어를 사용한다고 해서 → 애플리케이션의 복잡성이 잘 캡슐화를 보장할 수 없음 훌륭한 프로그래밍 기술을 적용해서 캡슐화 → 향상 객체지향 프로그래밍을 통해 전반적으로 얻을 수 있는 장점 : 오직 설계 과정 동안 캡슐화를 목표로 인식할 때만 달성

* 설계가 필요한 이유는 요구사이 변경되기 때문
  * 캡슐화가 중요한 이유는 불안정한 부분과 안정적인 부분을 분리하여 변경의 영향을 통제할 수 있기 때문
  * 변경의 관점에서 걸계의 품질을 판단한기 위해 캡슐화를 기준으로 삼을 수 있음

🌈 캡슐화 : 변경 가능성이 높은 부분을 → 객체 내부로 숨기는 추상화 기법 객체 내부에 무엇을 캡슐화? 변경될 수 있는 어떤 것이라도 → 캡슐화

### 응집도와 결합도

🌈 응집도 : 모듈에 포함된 내부 요소들이 연관돼 있는 정도

> 문제

🌈 좋은 설계 오늘의 기능을 수행하면서 → 내일의 변경을 수용할 수 있는 설계 좋은 설계를 만들기 위해서는 높은 응집도와 낮은 결합돌를 추구해야함 좋은 설계가 변경과 관련된 것이고 응집도와 결합도의 정도 → 설게의 품질을 결정한다면 자연스럽게 같은 결론에 도달하게 됨❓ 높은 응집도와 왜 낮은 결합도를 추구해야하나요?

* 설계를 변경하기 쉽게 만들기 때문
* 변경의 관점
  * 응집도란 변경이 발생할 때 모듈 내부에서 발생하는 변경의 정도

> 변경을 수용하기 위해 모듈 전체가 함께 변경 → 높은 응집도

> 변경을 수용하기 위해 모듈 일부만 변경 → 낮은 응집도

> 높은 응집도 → 하나로 모임

* 변경의 대상과 범위가 명확 → 코드를 변경하기 쉬워짐
* 변경으로 인해 수정되는 부분을 파악하기 위해 코드 구석구석을 헤맬 필요 없이 오직 하나만 수정

> 결합도 : 한 모둘이 변경되기 위해서 다른 모듈의 변경을 요궇나느 정도

* 하나의 모듈을 수정할 때 얼마나 많은 모듈을 함께 수정해야 하는지
* 결합도가 높으면 높을수록 함께 변경해야 하는 모듈의 수가 늘어나기 때문에 다른 모듈의 변경을 요구하는 정도
* 변경과 결합도 사이의 관계를 나타낸 것
  * 낮은 결합도를 가진 왼쪽의 설계에서는 모듈 A를 변경했을 때
  * 오직 하나의 모듈만 영향을 받는다는 것
* 영향을 받는 모듈의 수 외에도 변경의 원을 이용해 결합도의 개념을 설명할 수도 있음
  * 내부 구현을 변경했을 때 이것이 다른 모듈에 영향을 미치는 경우에는
  * 두 모듈 사이의 결합도가 높다고 표현함
* 퍼블릭 인터페이스를 수정했을 때만 다른 모듈에 영향을 미치는 경우 → 결합도가 낮다고 표현

> 클래스의 구현이 아닌 → 인터페이스에 의존하도록 코드를 작성해야 낮은 결합도를 얻을 수 있음
>
> 인퍼에스에 대해 프로그래밍하라 GOF94

* 직접 작성한 코드의 경우 : 이야기가 다름
  * 직접 작성한 코드 → 수정될 가능성

❄️ 강조사항

> 캡슐화의 정도가 응집도와 결합도에 영향을 미치는 사실
>
> 캡슐화를 지키는 모듈 안의 응집도는 높아지고 → 모듈 사이의 결합도는 낮아짐
>
> 캡슐화를 위반하면 모듈 안의 응집도는 낮아지고 → 모듈 사이의 결합도는 높아짐

> 응집도와 결합도를 고민하기 전에 캡슐화를 향상 시키기 노력

## 3. 데이터 중심의 영화 예매 시스템의 문제점

❄️ 데이터 중심의 설계 : 캡슐화를 위반하고 객체의 내부 구현을 인터페이스의 일부로 만듬🔥 책임 중심의 설계 : 객체 내부 구현을 안정적인 인터페이스 뒤로 캡슐화

> 캡슐화의 정도가 객체의 응집도와 결합도를 결정한다는 사실을 기억

* 데이터 중심의 설계 : 캡슐화를 위반하기 쉽기 때문에
* 책임 중심의 설계에 비해 응집도가 낮고 결합도가 높은 객체들을 양산하게 될 가능성이 높음

> 데이터 중심의 설계가 가진 대표적인 문제점

* 캡슐화 위반
* 높은 결합도
* 낮은 응집도

### 캡슐화 위반

```java
public class Movie {
	private Money fee;

	public Money getFee() {
		return fee;
	}

	public void setFee() {
		this.fee = fee;
	}
}
```

❓ 이 코드의 문제점은?

> 직접 객체의 내부에 접근할 수 없기 때문에 캡슐화의 원칙을 지키고 있는 것처럼 보임

* 접근자와 수정자 메서드 : 객체 내부의 상태에 대한 어떤 정보도 캡슐화하지 못함
* getFee 메서드, setFee 메서드는
  * Movie 내부에 Money 타입의 fee라는 이름의 인스턴스 변수가
  * 존재한다는 사실을 → 퍼블릭 인터페이스에 노골적으로 나타냄

> Movie가 캡슐화의 원칙을 어기게 된 근복적인 원인

* 객체가 수행할 책임이 아니라 → 내부에 저장할 데이터에 초점을 맞췄기 때문
* 객체에게 중요한 것은 : 책임
  * 구현을 캡슐화할 수 있는 적절한 책임 : 협력이라는 문맥을 고려할 때만 얻을 수 있음

> 설게할 때 협력에 관해 고민하지 않으면 캡슐화를 위반하는 과도한 접근자와 수정자를 가지는 경향

* 객체가 사용될 문맥을 추측할 수밖에 없는 경우
  * 개발자는 어떤 상황에서도 해당 객체가 사용될 수 있게 최대한 많은 접근 제어자를 가지도록 오류를 범함

❓ 접근자와 수정자에게 과도하게 의존하는 설계 방식 추측에 의한 설계 전략(design-by-gessing strategy)

* 이 전략은 객체가 사용될 협력을 고려하지 ㅇ낳고
* 객체가 다양한 상황에서 사용될 수 있을 것이라는 막연한 추측을 기반으로 설계를 진행함
* 프로그래머 : 내부 상태를 드러내는 메서드를 최대한 많이 집어 넣어야 한다는 압박

> 결론적으로 캡슐화의 원칙을 위반하는 변경에 취약한 설계

### 높은 결합도

> 객체 내부 구현이 객체의 인터페이스에 드러난다는 것

* 클라이언트가 구현에 강하게 결합된다는 것을 의미함
* 더 나쁜 소식 : 객체의 내부 구현을 변경 → 인터페이스에 의존하는 모든 클라이언트 모두 수정

❄️ 접근 제어자 getFee를 사용하는 것

> 인스턴스 변수 fee의 가시성을 private → public으로 변경하는 것과 동일함
>
> 데이터 중심 설계는 객체의 캡슐화를 악화시키기 때문에 클라이언트가 객체의 구현에 강하게 결합

* 결합도 측면 : 데이터 중심 설계가 가지는 또 다른 단점
  * 여러 데이터 객체들을 사용하는 제어 로직이 특정 객체 안에 집중
  * 하나의 제어 객체가 다수의 데이터 객체에 강하게 결합된다는 것
  * 결합도로 인해 어떤 데이터 객체를 변경하더라도 제어 객체를 함께 변경할 수밖에 없음

### 낮은 응집도

> 서로 다른 이유로 변경되는 코드가 하나의 모듈 안에 공존할 때 모듈의 응집도가 낮다고 말함

* 각 모듈의 응집도를 살펴보기 위해서 → 코드를 수정하는 이유가 무엇인지 살펴봐야 함

❄️ ReservationAgency를 예로 들어 변경과 응집도 사이의 관계를 살펴보자

* 할인 정책을 추가할 경우
* 할인 정책별로 할인 요금을 계산하는 방법이 변경될 경우
* 할인 조건이 추가되는 경우
* 할인 조건별로 할인 여부를 판단하는 방법이 변경될 경우

> 변경의 이유가 서로 다른 코드들을 하나의 모듈로 → 뭉쳐놓아 변경과 아무런 상관이 없는 코드들이 영향을 받게됨
>
> Resevervation 안에
>
> * 할인 정책을 선택하는 코드
> * 할인 조건을 판단하는 코드
>
> 함께 존재하기 때문에 새로운 할인 정책을 추가하는 작업이 → 할인 조건에도 영향을 미칠 수 있음

* 어떤 코드를 수정한 후에 아무런 상관도 없는 코드에 문제가 발생하는 것
  * 모듈의 응집도가 낮을 때 발생하는 대표적인 증상

> 하나의 요구사항이 변경을 반영하기 위해 동시에 여러 모듈을 수정해야 함
>
> * 응집도가 낮을 경우 다른 모듈에 위치해야 할 책임의 일부가 엉뚱한 곳에 위치하기 때문임

🎨 단일 책임 원칙 (SRP)

* 모듈의 응집도가 변경과 연관이 있다는 사실을 강조 : 단일 책임 원칙
* 클래스 : 단 한가지의 변경 이유만 가져야 한다는 것
  * 단일 책임 원칙이 클래스의 응집도를 높일 수 있는 설계 원칙
* 단일 책임 원칙이라는 맥락에서
  * 책임 → 변경의 이유
  * 단일 책임 원칙에서의 책임은 더 큰 개념을 가리킴

## 4. 자율적인 객체를 향해

### 캡슐화를 지켜라

> 캡슐화 : 설계의 제 1원리

* 객체는 자신이 어떤 데이터를 가지고 있는지를
  1. 내부에 캡슐화 하고
  2. 외부에 공개해서는 안됨
* 객체는 스스로의 상태를 책임져야 하며
* 외부에서는 인터페이스에 정의된 메서드를 통해서만 → 상태에 접근 가능해야 함

> 메서드

* 단순한 속성 하나의 값을 반환하거나
* 변경하는 접근자나 수정자를 의미하는 것은 아님

🎨 객체에게 의미 있는 메서드

> 객체가 책임져야 하는 무언가를 수행하는 메서드

* 속성의 가시성을 private → 접근자, 수정자를 통해 속성을 외부 노출? → 캡슐화를 위배함

✅ 이해를 돕기 위한 간단한 Class 사각형

* Rectangle은 사각형의 좌표들을 포함하고
  * 각 속성에 대한 접근자와 수정자 메서드를 제공함

```java
class Rectangle {
	private int left;
	private int top;
	private int right;
	private int bottom;

	public Rectangle(int left, int top, int right, int bottom) {
		this.left = left;
		...
	}

	public int getLeft() { return left; }
	public void setLeft(int left) { this.left = left; }

	... 동일
}
```

* 너비와 높이를 증가시키는 코드가 필요하다고 가정

> 사각형의 너비와 높이를 증가 시키는 코드 가정

```java
class AnyClass {
	void anyMethod(Rectangle rectangle, int mpltiple) {
		rectangle.setRight(rectangle.getRight() * mulitple);
		rectangle.setLeft(rectangle.setLeft() * mulitple);
	}
}
```

❄️ 많은 문제점들이 도사리는 코드

1. 코드 중복이 발생할 확률이 높음

*   다른 곳에서 너비와 높이를 증가시키는 코드가 필요하다면 → 동일하게 접근자, 제어자를 통해서

    유사한 코드가 존재할 가능성이 높아짐

    * 코드의 중복 : 악의 근원
    * 코드 중복을 초래할 수 있는 모든 원인을 제거하는 것이 중요함

1. 변경에 취약함

* right, bottom 대신 → length, height를 이용한 사각형을 표현하도록 수정한다고 가정
  *   접근자와 수정자는 내부 구현을 인터페이스의 일부로 만들기 때문에

      현재의 Rectangle 클래스 : top, left, right, bottom이라는 4가지 인스턴스 변수의 존재사실을

      인트페이스를 통해 외부로 노출

❓ 해결 방법이 뭐에요?

> 캡슐화를 강화 시키는 것
>
> Rectangle 내부에 너비와 높이를 조절하는 로직을 캡슐화 하면
>
> 두 가지 문제를 해결 할 수 있음

```java
class Rectangle {
	public void enlarge(int multiple) {
		right *= mulitiple;
		bottom *= mulitiple;
	}
}
```

* 우리는 Rectangle을 변경하는 주체를
  * 외부의 객체 → Rectangle로 이동시켰음

> 즉 : 자신의 크기를 Rectangle 스스로 증가시키도록 책임을 이동

* 객체가 자기 스스로를 책임진다는 말의 의미

### 스스로 자신의 데이터를 책임지는 객체

* 우리가 상태와 행동을 객체라는 하나의 단위로 묶는 이유
  * 객체 스스로 자신의 상태를 처리할 수 있기 하기 위함
  * 객체는 단순한 데이터 제공자가 아님
  *   객체 내부에 저장되는 데이터보다 객체가 협력에 참여하면서

      수행할 책임을 정의하는 이 오퍼레이션이 더 중요

> 객체를 설계할 때 이 객체가 어떤 데이터를 포함해야 하는가?

1. 이 객체가 어떤 데이터를 포함해야 하는가?
2. 이 객체가 데이터에 대해 수행해야 하는 오퍼레이션은 무엇인가?

> 두 질문 조합 : 객체의 내부 상태를 저장하는 방식과 저장된 상태에 대해 호출할 수 잇는 오퍼레이션의 집합을 얻을 수 있음 → 다시 말해 새로운 데이터 타입을 만들 수 있는 것

> 다시 영화 예매 시스템 예제

* ReservationAgency로 새어나간 데이터에 대한 책임을 → 실제 데이터를 포함하고 있는 객체
* 할인 조건을 표현하는 DiscountCondition에서 시작

1. 어떤 데이터를 관리해야 하나?
2. 이 데이터에 대해 수행할 수 있는 행동이 무엇인가?

> 할인 조건에는 순번 조건과 기간 조건의 두 가지 종류가 존재한다는 사실을 기억

* DiscountCondition은
  * 순번 조건인 경우 → sequence를 이용해서 → 할인 여부를 결정
  * 기간 조건인 경우 → dayOfWeek, startTime, endTime을 이용해 → 할인 여부를 결정

```java
public class DiscountCondition {
	public DiscountConditionType getType()
}
```

> 이제 Movie를 구현 → 첫 번째 질문 ?

```java
public class Movie {
	private String title;
	private Duration runningTime;
	private Money fee;
	private List<DiscountCondition> discountCondition;

	private MovieType movieType;
	private Money discountAmount;
	private double discoutPercent;
}
```

> 요금을 계산하기 위해서는 할인 정책을 염두에 둬야함

* 할인 정책
  * 금액 할인
  * 비율 할인
  * 할인 미적용의 세가지 타입
* 따라서 DiscountCondition과 마찬가지로 할인 정책의 타입을 반환하는
  * getMovieType 메서드
  * 정책별로 요금을 계산하는 세 가지 메서드

### 느낀점

> 결합도 측면에서 몰려 있던 의존성이 개선된 것으로 보임

* 두 번째 설계가 첫 번째 설게보다 내부 구현을 더 면밀하게 캡슐화 하고 있음
* 두 번째 설계에서는 데이터를 처리하는 데 필요한 메서드들이 데이터를 가지고 있는 객체 스스로 구현하고 있음
* 이 객체들은 스스로를 책임짐

## 5. 하지만 여전히 부족함

> 여전히 데이터 중심의 설계 방식

### 캡슐화 위반

> 분명히 수정된 객체들은 자기 자신의 데이터를 스스로 처리함

* 하지만 DiscountCondition에 구현된 두 개의 isDiscountable 메서드 : 몇 군데 이상한 점
*   기간 조건을 판단하는 isDiscountable(DayOfWeek, dayOfWeek, LocalTime time)

    메서드의 시그니처 → DayOfWeek 타입의 요일 정보

    LocalTime의 타입의 시간 정보를 포함하고 있음
* 이는 정보들이 인스턴스 변수로 포함되고 있다는 사실을 인터페이스를 통해 외부로 노출

❓ 그럼 어떻게 해결하나요?

* 해당 메서드를 사용하는 모든 클라이언트도 모두 수정을 해야함
* 내부 구현 변경이 외부로 퍼져나가는 파급 효과(ripple effect) 캡슐화가 부족하다는 명맥한 증거

❓ 캡슐화의 진정한 의미

> 캡슐화가 단순히 객체 내부의 데이터를 외부로부터 감추는 것 이상의 의미를 가진다는 것을 잘 보여줌

* 캡슐화는 변경될 수 있는 어떤 것이라도 감추는 것을 의미함
* 내부 속성을 외부로부터 감추는 것은 “데이터 캡슐화” 라고 불리는 캡슐화의 한종류
* 캡슐화 : 변화할 수 잇는 어떤 것이라도 감추는 것
* 속성의 타입, 할인 정책의 종류건 상관 없이 → 내부 구현의 변경으로 인해 → 외부 객체가 영향을 받는다면

> 이는 캡슐화의 우환

설계 에서 변하는 것이 무엇인지 고려하고 → 변하는 개녀믈 캡슐화

> 캡슐화 → 변하는 어떤 것이든 감추는 것
>
> 그것이 무엇이든 구현과 관련된 것이라면

### 높은 결합도

* 캡슐화 위반 → 내부 구현 → 외부로 노출 → 결합도 높아짐
* 할인 조건의 명칭이 변경 → Movie 수정
* DiscountCondition의 종류 추가, 삭제 → Movie 안의 if, else 구문을 수정

### 낮은 응집도

* DiscountConditon이 할인 여부를 판단하는 데 필요한 정보가 변경된다면
* Movie의 isDiscountable 메서드로 전달해야 하는 파라미터의 종류를 변경해야 하고
  * 이로 인해 메서드를 호출하는 부분도 함께 변경해야 함

> 안타깝게도 캡슐화가 덜 진행 되 문제점을 가짐

## 6. 데이터 중심 설계의 문제점

> 데이터 중심의 설계가 변경에 취약한 이유

1. 데이터 중심의 설계 : 본질적으로 너무 이른 시기에 데이터에 관해 결정하도록 강요
2. 데이터 중심의 설계 : 문맥을 고려하지 않고 객체를 고립시킨 채 오퍼레이션을 결정

### 데이터 중심 설게는 객체의 행동보다는 상태에 초점

> 데이터 중심 설계

1. 이 객체가 포함해야 하는 데이터?

* 데이터는 구현의 일부

> 데이터 주도 설계 : 데이터에 대한 결정을 강요 → 너무 이른 시기에 내부 구현에 초점

* 데이터 중심 설계 → 일반적으로 데이터와 기능을 분리하는 절차적 프로그래밍 방식
* 상태와 행동을 하나의 단위로 캡슈롸 하는 객체지향 패러다임에 반하는 것

> 데이터 중심 관점 → 객체 : 단순한 데이터 집합체

* 접근자, 수정자의 과한 추가
* 이 데이터 객체를 사용하는 절차를 분리된 별도의 객체 안에 구현

❓ 데이터를 처맇나느 작업과 데이터를 같은 객체 안에 둔다면요?

* 데이터를 먼저 결정하고 → 데이터를 처리하는 데 필요한 오퍼레이션을 나중에 결정하는 방식
* 데이터에 관한 지식이 객체의 인터페이스에 고스란히 드러나게 됨
* 결좌거으로 → 객체의 인터페스는 구현을 캡슐화하는 데 실패하고 → 코드는 변경에 취약

### 데이터 중심 설계는 객체를 고립시킨 채 오퍼레이션을 정의하도록 만든다.

> 객체지향 애플리케이션을 구현한다는 것

* 객체들의 공동체를 구축한다는 것을 의미함
* 협력이라는 문맥 안에서 → 필요한 책임을 결정하고 → 이를 수행할 적절한 객체를 결정하는 것이 중요함
  * 올바른 객체지향 설계의 무게 중심은 항상 객체의 내부가 아닌 → 외부에 맞춰져야함

> 객체가 어떤 상태를 가지고

> 그 상태를 어떻게 관리 → 부가적 문제

❓ 데이터 중심의 설계는 객체의 외부가 아닌 내부로 향함

* 실행 문맥에 대한 깊은 고민 없이 → 객체가 괸리할 데이터의 세부 정보를 먼저 결정
* 객체의 구현이 이미 결정된 상태에서 다른 객체와 협력 방법 → 객체의 인터페이슬르 억지로 끼워넣음
