# 😆 8. OBJ 의존성 관리하기



## 8. 의존성 관리하기

### 정리

* 의존성을 직접 new로 생성해서 관리가 가능함
  * 런타임 시점과 컴파일 시점을 분리해서 관리가 가능함
  * 만약 정보만 필요하면 메서드의 인자로 넘기도록

순환 참조

컴파일 타임, 런타임 → 설계 측면에서 그렇게 주입

조형우 객체지향

### 들어가며

> 잘 설계된 객체지향 애플리케이션 : 작고 응집도 높은 객체들로 구성

* 작고 응집도 높은 객체
  * 초점이 명확하고
  * 한 가지 일만 잘 하는 객체를 의미함
*   이런 작은 객체들은 단독으로 수행할 수 있는 일이 없음

    → 고로 다른 객체들에게 도움을 요청

    이를 협력이라고 함

🎨 과도한 협력의 문제점

* 협력은 객체가 다른 객체에 대해 알것을 강요함
* 객체지향 설계의 핵심은 협력을 위해 필요한 의존성을 유지하면서도
  * 변경을 방해하는 의존성은 제거하는 데 있음
  * 객체지향 설계란 의존성을 관맇나는 것이고
  * 객체가 변화를 받아들일 수 있게 의존성을 정리하는 기술

## 1. 의존성 이해하기

### 변경과 의존성

어떤 객체가 협력하기 위해 다른 객체를 필요할 때 두 객체 사이의 의존성이 존재하게 됨

* 의존성은 실행 시점과 구현 시점에 서로 다른 의미를 가지게 됨
*   실행 시점 : 의존하는 객체가 정상적으로 동작하기 위해서는 실행 시에 의존 대상

    객체가 반드시 존재해야함
* 구현 시점 : 의존 대상 객체가 변경할 경우 의존하는 객체도 함께 변경됨

> 어떤 객체가 예정된 작업을 정상적으로 수행하기 위해서는 다른 객체를 필요로 하는 객체의 경우
>
> 두 객체 사이에 의존성이 존재하ㄴ다고 말함

* 의존성은 방향성을 가지며 항상 단방향임

> 두 요소 사이의 의존성은 의존되는 요소가 될 때 의존하는 요소도 함께 변경될 수 있다는 것을 의미함

> UML과 의존성

```jsx
UML(United Modeling Language)에 익숙한 사람이라면 
UML에서 정의하는 의존 관계와는 조금 다르다는 사실을 눈치챘을 것임
```

### 의존성 전이

> 의존성 전이

* 한 대상이 다른 대상에 의존하는 경우
  * 의존도가 계속 의존하게 됨
  * 간접적으로 의존도가 커짐
* 의존성은 함께 변경될 수 있는 가능성을 의마힉 때문에 모든 경우에 의존성은 전이되는 것은 아님
  * 의존성이 실제로 전될지 여부는 변경의 방향과 캡슐화의 정도에 따라 달라짐
  *   어떤 요소의 구현이나 인터페이스가 변경되는 경우

      캡슐화가 잘 되어 있다면 → 변경 사항이 전파되지는 않음
*   의존성이 전이될 수 있기 때문에 의존성의 종류를 직접 의존성(direct dependency)와

    간접 의존성(indirect dependency)으로 나누기도 함
* 직접 의존성
  * 말 그대로 한 요소가 다른 요소에 직접 의존하는 경우를 기리킴
* 간접 의존성
  * 직접적인 관계는 존재하지 않지만
  * 의존성 전이에 영향이 전파되는 경우

🎨 의존성의 본질

* 의존성이란 의존하고 있는 대상의 변경에 영향을 받을 수 있는 가능성

### 런타임 의존성과 컴파일 타임 의존성

#### 런타임 의존성

* 애플리케이션이 실행되는 시점을 가리킴

#### 컴파일 타임

* 작성된 코드를 컴파일 하는 시점을 가리키지만 문맥에 따라서는 코드 그 자체를 가리키도 함

🎨 그럼 이게 왜 중요한가요?

* 시간이 아닌 우리가 작성한 코드의 구조이기 때문
* 동적 타입의 언어의 경우 → 컴파일 타임이 존재하지 않음
  * 고로 컴파일 타임 → 실제로 컴파일이 수행되는 시점으로 이해하면 의미가 모호

> 객체지향 애플리케이션 - 런타임 주인공 : 객체

* 런타임 의존성이 다루는 주제는 객체 사이의 의존성

> 코드 관점의 주인공 : 객체

* 컴파일타임 의존서이 다루는 주체는 클래스 사이의 의존성
* 여기서 중요한 것은 : 런타임 의존성과 컴파일타임 의존성이 다를 수 있다는 것임
* 사실 유연하고 재사용 가능한 코드를 설계하기 위해서는 두 종류의 의존성을 서로 다르게

🎨 협력

*   코드 작성 시점의 코드는 클래스의 존재를 모르지만

    실행 시점의 객체는 클래스의 인스턴스와 협력이 가능해짐
*   유연하고 재사용 가능한 객체를 창조하기 위해서는

    동일한 소스코드 구조를 가지고 다양한 실행 구조를 만들 수 있어야 함
*   어떤 클래스의 인스턴스가 다양한 클래스의 인스턴스와 협력하기 위해서는

    협력할 인스턴스의 구체적인 클래스를 알아서는 안됨
* 실제로 협력할 객체가 어떤 것인지 → 런타임에서 해결해야함

> 클래스가 협력할 객체의 클래스를 명시적으로 드러낸다면 → 다른 클래스의 인스턴스와

협력할 가능성 자체가 사라짐

컴파일타임 구조와 런타임 구조 사이의 거리가 멀면 → 설계가 유연해지고 재사용 가능해짐

### 컨텍스트 독립성

* 유연하고 확장 가능한 설계 → 컴파일 의존성과 런타임 의존성이 달아야함
* 클래스는 자신과 협력할 객체의 구체적인 클래스에 대해 알아서는 안됨

🎨 클래스가 특정한 문맥에 강하게 결합될수록 → 다른 문맥에서 사용하기는 더 어려워짐 - 클래스가 사용될 특정한 문맥에 대해 최소한의 가정만으로 이뤄져 있다면 - 다른 문맥에서 재사용하기가 더 수월해짐 - 이를 \`컨텍스트 독립성\`

> 설계가 유연해지기 위해서는

* 가능한 자신이 실행될 컴텍스트에 대한 구체적인 정보를 적게 알야아 함

### 의존성 해결하기

* 컴파일타임 의존성은 구체적인 런타임 의존성으로 대체

> 컴파일타임 의존성 → 실행 컨텍스트에 맞는 적절한 런타임 의존성으로 교체

→ 의존성 해결

1. 객체를 생성하는 시점에 생성자를 통해 의존성 해결
2. 객체 생성 후 setter 메서드를 통해 의존성 해결
3. 메서드 실행 시 인자를 이용해 의존성 해결

```jsx
Movie avatar = new ("아바타",
	Duration.ofMinutes(120),
	Money.wons(1000),
	new AmoutDiescountPolicy(...));
```

> Movie 클래스는 PercentDiscountPolicy 인스턴스와 AmountDiscountPolicy 인스턴스 모두를
>
> 선택적으로 전달받을 수 있도록
>
> 이 두 클래스의 부모 클래스인 DiscountPolicy 타입의 인자를 받는 받는 생성자를 정의함

```jsx
public class Movie {
	public Movie(String title, Duration runningTime, Monye fee, DiscountPolicy discount Policy) {
		this.discountPolicy = discountPolicy;
	}
}
```

> Moive 인스턴스를 생성한 후에 메서드를 이용해 의존성 해결

```jsx
Movie avatart = new Movie(...));
avatart.setDiscountPolicy(new AmcountDiscountPolicy(...));
```

* 이 경우 Movie 인스턴스가 생성된 후에도 DiscountPolicy를 설정할 수 있는 setter 메서드를 제공함

```jsx
public class Movie {
	public void setDiscountPolicy (DiscountPolicy discountPolicy) {
		this.discountPolicy = discountPolicy;
	}
}
```

> setter 메서드를 이용하는 경우

* 객체를 생성한 이후에도 의존하고 있는 대상을 변경할 수 있는 가능성을 열어 놓고 싶은 경우에 유용
* 금액 할인 정책으로 설정된 Movie 인스턴스를 중간에 비율 할인 정책으로 변경 가능함

```jsx
Moive avatar = new Move(...));
avatar.setDiscountPolicy(new AmountDiscountPolicy(...));
...
avatar.setDiscountPolicy(new PercentDiscountPolicy(...));
```

🎨 setter 메서드의 이용의 장/단점

* 실행 시점에 의존 대상을 변경할 수 있기 때문에
  * 설계를 좀 더 유연하게 만들 수 있음

> 단점

* 객체가 생성된 후에 협력에 필요한 의존 대상을 설정하기 때문에
* 객체를 생성하고 의존 대상을 설정하기 전까지는 객체의 상태가 불완전할 수 있다는 점임

🎨 그럼 해결 방법은?

* 생성자 방식과 setter 방식을 혼합하는 것임
*   항상 객체를 생성할 때 의존성을 해결해서 완전한 상태의 객체를 생성한 후

    필요에 따라 setter 메서드를 이용해 의존 대상을 변경하도록
*   이 방법은 시스템의 상태를 안정적으로 유지하면서도

    유연성을 향상시킬 수 있기 때문에

    읜존성 해결을 위해 선호되는 방식 중 하나임

```jsx
Movie avatar = new Movie(..., new PercentDiscountPolicy(...)));

avatar.setDiscountPolicy(new AmcountDiscountPolicy));
```

> Movie가 항상 할인 정책을 알 필요는 없고

가격을 계산할 때만 일시적으로 알아도 된다면 → 메서드의 인자를 통해서 이를 해결

## 2. 유연한 설계

### 2.1 의존성과 결합도

* 객체지향 패러다임의 근간 : 협력
* 협력하기 위해서는 → 서로의 존재와 수행 가능한 책임을 알야아함
  * 이런 자식들이 객체 사이의 의존성을 낳음
  * 모든 의존성은 나쁜 것이 아님
  * 객체들의 협력을 가능하게 만드는 매개체라는 관점에서 바람직한 것

> 모든 의존성은 나쁘지 않지만 → 이를 좀 더 바람직한 의존성으로 만들기

🎨 협력하고 싶은 대상이 하나에만 종속적이지 않도록

* 협력할 객체의 클래스를 고정할 필요가 없음
*   자신이 전송하는 메시지를 이해할 수 있고 할인된 요금을 계산할 수 만 있다면

    어떤 타입의 객체와 협력하더라도 상관이 없음

🎨 바람직한 의존성

* 재사용성과 관련이 있음
* 어떤 의존성이 다양한 환경에서 클래스를 재사용할 수 업도록 제한한다면 → 그 의존성은 바람직하지 못함
* 어떤 의존성이 다양한 환경에서 재사용할 수 있다면 → 그 의존성은 바람직한 것

> 컴텍스트에 독립적인 의존성 : 바람직한 의존성

> 특정한 컨텍스트에 강하게 결합된 의존성 : 바람직하지 않은 의존성

> 다른 화경에서 재사용하기 위해 내부 구현을 변경하게 만드는 모든 의존성은 바람직하지 않은 의존성

* 바람직함
  * 컨텍스트에 독립적인 의존성을 가짐
  * 다양한 환경에서 재사용될 수 있는 가능성을 열어 놓는 의존성

🎨 의존성과 결합도

```jsx
일반적으로 의존성과 결합도를 동의어로 사용하지만
사실 두 용어는 서로 다른 관점에서 관계의 특성을 설명하는 용어

의존성 : 두 요소 사이의 관계 유무를 설명함
의존성의 관점에서는 존재, 존재하지 않음 BOOL

결합도 : 두 요소 사이의 존재하는 의존성의 정도를
상대적으로 표현함
결합도의 관점에서는 결합도가 강하다, 느슨하다.
```

### 지식이 결합을 낳는다.

> 서로에 대해 알고 있는 지식의 양이 결합도를 결정함

이제 지식이라는 관점에서 살펴보기

더 많이 알수록 더 많이 결합됨

* 더 많이 알고 있다는 것은 → 더 적은 컨텍스트에서 재사용 가능하다는 것을 의미함
*   기존 지식에 어울리지 않는 컨텍스트에서 클래스의 인스턴스를 사용하기 위해서

    할 수 있는 유일한 방법은 클래스를 수정하는 것뿐임
* 결합도를 느슨하게 유지하려면 협력하는 대상에 대해 더 적게 알아야 함
*   결합도를 느슨하게 만들기 위해서는 협력하는 대상에 대해 필요한 정보 외에

    최대한 감추는 것이 중요함

### 추상화에 의존하라

🎨 추상화

*   어떤 양상, 세부사항, 구조를 좀 더 명확하게 이해하기 위해

    특정 절차나 물체를 의도적으로 생략하거나 감춤으로써 복잡도를 극복하는 방법

    추상화를 사용하면 현재 다루고 잇는 문제를 해결하는 데 불필요한 정보를 감출 수 있음
* 대상에 대해 알아야 하는 지식의 양을 줄일 수 있기 때문에 결합도를 느슨하게 유지할 수 있음

🎨 추상화와 결합도의 관점에서 의존 대상을 다음과 같이 구분하기

* 구체 클래스 의존성(concrete class dependency)
* 추상 클래스 의존성(abastract class depedency)
* 인터페이스 의존성(interaface dependency)

> 인터페이스에 의존하면 상속 계층을 모르더라도 → 협력이 가능해짐

* 인터페이스 의존성은 협력하는 객체가 어떤 메시지를 수신할 수 있는지에 대한 지식만 남김
* 추상 클래스 의존성보다 결합도가 낮음
* 다양한 클래스 상속 계층에 속한 객체들이 동일한 메시지를 수신할 수 있또록
* 컨텍스트를 확장하는 것을 가능하게함

> 의존하는 대상이 더 추상적일수록 → 결합도는 낮아짐

### 명시적인 의존성

```jsx
public class Movie {
	private DisccountPolicy discountPolicy;

	public Movie(String title, Duration runningTime, Money fee) {
		...
		this.discountPoliicy = new AmountDiscountPolicy(...);
	}
}
```

🎨 결합도를 느슨하게 만들기 위해서는 인스턴스 변수의 타입을 추상 클래스나 인터페이스에 선언하는 것으로는 부족함

> 클래스 안에서 구체 클래스에 대한 모든 의존성을 제거해야 함

* 런타임에 Movie는 구체 클래스의 인스턴스와 협력해야 하기 때문에
* Movie의 인스턴스가 무엇인지 알려줄 필요함
  * → Movie의 의존성을 해결해 줄 수 있는 방법이 필요한 것

> 의존성 해결 방식

1. 생성자
2. setter 메서드
3. 메서드 인자

> 생성자 안에서 인스턴스를 직접 생성하지 않고 → 생성자의 인자로 선언하기

```jsx
public class Movie {
	private DisccountPolicy discountPolicy;

	public Movie(String title, Duration runningTime, Money fee, DiscountPolicy discountPolicy) {
		...
		this.discountPoliicy = discountPolicy;
	}
}
```

* 런타임에서 인스턴스를 선택이 가능함

> 차이점

* 퍼블릭 인터페이스를 통해 할인 정책을 설정할 수 있는 방법을 제공하는지 여부

→ 의존성을 명시적으로 퍼블릭 인터페이스에 노출

→ 명시적인 의존성(explict dependency)

🎨 내부에서 직접 생성하는 방식

* 의존성이 퍼블릭 인트페스에 표현되지 않음
* 숨겨진 의존성 (hidden dependency)

> 의존성이 명시적이지 않다면

* 의존성을 파악하기 위해 → 세부 로직을 탐험
* 커다른 클래스에 정의된 긴 메서드 내부에 어디선가 인스턴스를 생성하는 코드를 찾는 일은 고통 스러움

> 클래스가 다른 클래스에 의존하는 것은 부끄러운 일이 아님

* 의존성은 다른 객체와의 협력을 가능 → 바람직한 일
* 경계해야 할 것은 : 의존성 자체가 아닌 의존성을 감추는 것

### new는 해롭다.

> new를 잘못 사용하면 클래스 아이의 결합도가 극단적으로 높아짐

* 결합도 측면에서 new가 해로운 이유

1.  new 연산자를 사용하기 위해서는 구체 클래스의 이름을 직접 기술해야 함

    따라서 new를 사용하는 클라이이언트 → 구체 클래스에 의존

    결합도가 높아짐
2.  new 연산자는 생성하려는 구체 클래스뿐만 아니라 어떤 인자를 이용해 클래스의 생성자를 호출해야 하는지도 알아야함

    new를 사용하면 클라이이언트가 지식의 양이 늘어나기 때문에 결합도가 높아짐

> 구체 클래스에 직접 의존하면

* 결합도가 높아짐
* 결합도 관점에서 구체 클래스 → 협력자에게 너무 많은 지식을 알도록 강요함
* 클라이언트 구체 클래스 → 어떤 정보가 필요하는지에 대해서도 알아야 함

> 결합도가 높으면 변경에 의한 영향을 받기 쉬워짐

* 생성자의 인자 목록이나 인자 순서를 바꾸는 경우에도 함께 변경될 수 있음
* 의존성이 높아지면 → 더 변경에 취약해지기 때문에 높은 결합도를 피해야 하는 이유

> 의존성 외에 모든 다른 의존성

* 결합도를 높이는 불필요한 의존성
* new는 이런 불필요한 결합도를 급격하게 높임

### 컨텍스트 확장하기

* Movie가 유연하다는 사실을 입증하기 위해
  1. 할인 혜택을 제공하지 않는 영화의 경우
  2. 다수의 할인 정책을 중복해서 적용하는 영화를 처리하는 경우

```jsx
```
