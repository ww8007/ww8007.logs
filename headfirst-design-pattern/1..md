# 1. 디자인 패턴으로 떠나기

## 디자인 패턴의 세계로 떠나기

날짜: 2022년 12월 31일 태그: ✅ 완료

## 디자인 패턴 소개와 전략 패턴

### 정리

> 디자인 원칙

* [ ] 상속보다는 구현
* [ ] 구현 보다는 인터페이스에 맞춰서 프로그래밍
* [ ] 애플리케이션에서 변하는 것과 변하지 않는 것을 분리한다.

## 오리 시뮬레이션 게임, SimUduck

> 객체지향 기법을 사용하여 Duck이라는 슈퍼 클래스
>
> 클래스를 확장해서 서로 다른 종류의 오리

***

## 오리 시뮬레이션 게임 차별화하기

❓ 객체지향 프로그래머에게 요구사항을 충족 시키는 일이 어려운가?

> 몰루?

***

## 또 다시 문제가 된 상속

> 서브클래스에서 코드가 중복된다.

> 오리가 춤추가 만들 수 없다.

> 모든 오리의 행동을 알기 힘들다.

> 코드를 변경했을 때 다른 클래스에 원하지 않은 영향을 끼칠 수 있다.

***

## 인터페이스 설계하기

> 앞으로 `규격이 계속 바뀔 거라는 사실`

* 너무나도 명확함
* 단지 날아가는 동작을 바꾸기 위해서
  * 서브클래스에서 날아가는 동작을 48개를 수정해야 하는 것

***

## 해결 방법 고민하기

✅ 기존 코드에 미치는 영향을 최소한으로 줄이면서 작업할 수 있는 방법이 존재 한다면 행복하지 않을까?

***

## 소프트웨어 개발 불변의 진리

> 아무리 디자인을 잘한 애플리케이션이라도 시간이 지남에 따라
>
> 변화하고 성장해야 함

***

## 문제를 명확하게 파악하기

### 디자인 원칙

✅ 애플리케이션에서 달라지는 부분을 찾고 달라지지 않는 부분과 분리한다.

> 달라지는 부분을 찾아서 나머지 코드에 영향을 주지 않도록 캡슐화 하는 것

> 코드를 변경하는 과정에서
>
> 의도치 않게 발생하는 일을 줄이면서 시스템의 유연성을 향상시킬 수 있음

***

## 바뀌는 부분과 그렇지 않은 부분 분리하기

> 변화하는 부분과 그대로 있는 부분을 분리하기 위해서는

* 2개의 클래스 집합(set)을 만들어야 함
  * 나는 것
  * 꽥꽥 거리는 것

> 각 클래스 집합에는 각각의 행동을 구현한 것을 전부 집어 넣기

## 오리의 행동을 디자인하는 방법

> 최대한 유연하게!

* [ ] 지금까지 발생한 문제들은 오리의 행동에 관련된 유연성
  * Duck의 인스턴스에 행동을 할당할 수 있어야함
* [ ] Duck의 인스턴스에 행동을 할당할 수 있도록
* [ ] 인스턴스를 새로 만들고 특정 형식의 나는 행동으로 초기화
* [ ] 오리의 행동을 동적으로 바꿀 수 있도록
  *   세터 메소드를 포함해서 프로그램 실행 중에도

      MallardDuck의 나는 행동을 바꿀 수 있ㄷ로ㅗㄱ
*   [ ] 각 행동은 → 인터페이스로 `표현`하고

    인터페이스를 사용해서 → 행동을 `구현`

> 이 방법은 Duck 클래스 자체에서 구현하거나
>
> 서브클래스 자체에서 별도로 구현하는 방법과 상반된 방법

* 특정 구현에 의존했기 때문에 → 행동을 변경할 여지가 없음

### 인터페이스에 맞춰서 프로그래밍 한다는 말

사실 상위 형식에 맞춰서 프로그래밍 한다는 말

❓ 인터페이스가 뭔가요?

> 자바의 구조를 지칭하는 용도로 쓰이기도 하고 인터페이스라는 개념을 지칭하는 용도로도 쓰임

*   인터페이스에 맞춰서 프로그래밍 해라! 라는 말이

    반드시 자바의 인터페이스를 사요하라는 의미는 아님

> 핵심적인 목표는 객체가 코드에 고정되지 않도록
>
> 상위 형식(supertype)에 맞춰서 프로그래밍해서 다형성을 활용하는 것

✅ 상위 형식에 맞춰서 프로그래밍 해라

추상 클래스나 인터페이스 같은 상위 형식으로 선언해야 함

객체를 변수에 대입할 때 상위 형식을 구체적으로 구현한 형식이라면

어떤 객체든 넣을 수 있기 때문임

#### 1. 구현에 맞춰서 프로그래밍

```java
Dog d = new Dog();
d.bark();
```

> 변수 d를 Dog 형식(Animal을 확장한 구상클래스)으로 선언하면
>
> 구체적인 구현에 맞춰서 코딩해야함

#### 2. 인터페이스 상위 형식에 맞춰서 프로그래밍

```java
Animal animal = new Dog();
animal.makeSound();
```

> Dog라는 걸 알고 있긴 하지만
>
> 다형성을 활용해서 Animal의 레퍼런스를 써도 됨

#### 3. 더 바람직한 방법

```java
a = getAnimal();
a.makeSound();
```

> 상위 형식의 인스턴스를 만드는 과정을
>
> 직접 코드로 만드는 대신 → `구체적으로 구현된 객체를 실행 시에 대입하는 것`

> Animal의 하위 형식 가운데 → 어떤 형식인지를 모름
>
> 단지 makeSound()에 올바른 반응만 할 수 있으면 됨

## 오리의 행동을 구현하는 방법

> 인터페이스에 맞춰서 프로그래밍 하기

> 이런 식으로 디자인 하면 다른 형식의 객체에서도
>
> 나는 행동, 꽥꽥 거리는 행동을 재사용할 수 있음
>
> → 왜냐? → 행동이 더 이상 Duck 클래스 안에 숨겨져 있지 않기 때문

> 기존의 행동 클래스를 수정하거나 날아다니는 행동을 사용하는
>
> Duck 클래스를 전혀 건드리지 않고도 새로운 행동을 추가가 가능함

### 질문

✅ 매번 애플리케이션 구현마다 바뀌는 부분을 찾아낸 후 바뀌는 것과 바뀌지 않는 것을 캡슐화 하는 작업을 해야할까요?

> 개발 라이프 사이클의 어느 단계에서든 적용이 가능합니다.

✅ 행동만 나타내는 클래스를 만드는게 조금 이상해 보여요. 클래스는 원래 어떤 대상을 나타내는 것 아닌가요? 클래스에는 상태와 행동이 모두 들어있어야 하지 않나요?

> 클래스는 일반적으로 상태(인스턴스 변수) 메소드를 둘 다 가지고 있음

* 우리의 예제에서는 클래스가 행동을 가지고 있음
* 하지만 행동에도 여전히 상태와 메소드가 들어가있을 수 있음
* 나는 행동에도 속성과(1분당 날개를 펄럭이는 횟수, 최고 높이, 높이, 속도) 포함이 가능함

## 오리 행동 통합하기

> 가장 중여한 점

*   나는 행동, 꽥꽥 거리는 행동

    서브 클래스에서 정의한 메소드를 써서 구현하는 것이 아닌

    다른 클래스에 `위임`

### 1. 행동 인터페이스, 기본 메소드 부리

> Duck

> FlyBehavior flyBehavior
>
> QuackBehavoir quackBehavior

> performQuck()
>
> swim()
>
> display()
>
> performFly()

### 2. performQuack() 구현

```java
public abstract class Duck {
	QuackBehavior quackBehavior;

	public void performQuack() {
		quackBehavoir.quack();
	}
}
```

> 꽥꽤 거리는 행동을 하고 싶을 때 quackBehavior에 의해 참조되는 객체에서
>
> 꽥꽥 거리도록 함
>
> 객체의 종류에는 전혀 신경 쓸 필요없이 quack()을 실행할 줄 알면됨

### 3. 인스턴스 변수 설정

```java
public class MallardDuck extends Duck {
	public MallardDuck() {
		quckBehavior = new Quack();
		flyBehavior = new FlwyWithWings();
	}

	publick void display() {
		System.out.println("저는 물오리 입니다.");
	}
}
```

1. MallardDuck의 인스턴스 생성
2.  생성자는 Duck으로부터 상속 받은 quackBehavior 인스턴스 변수에

    Quck(QuackBehavior를 구현한 구상 클래스) 형식으로 새로운 인스턴스를 대입
3. 나는 행동도 마찬가지

❄️ 특정 구현에 맞춰서 프로그래밍 하면 안되지 않나요? 생성자를 보면 Quack이라는 구현되어 있는 구상 클래스의 인스턴스를 마들었잖아요

> 행동을 구상 클래스로 설정을 하고 있지만
>
> 실행 시에 쉽게 변경할 수 있음

## 동적으로 행동 지정하기

> 동적으로 만들었는데 왜 사용을 안할 이유가 없음
>
> 행동 형식을 생성자에서 인스턴스를 만드는 방법이 아닌
>
> Duck의 서브 클래스에서 세터 메서드(setter method)를 호출하는 방법으로

### 1. Duck 클래스에 메서드 2개를 새로 추가

```java
public void setFlyBehavior(FlyBehavior fb) {
	flyBehavior = fb;
}

public void setQuackBehavior(QuackBehavior qb) {
	QuackBehavior = qb;
}
```

### 2. Duck의 서브클래스(ModelDuck.java) 새로 생성

```java
public class ModelDuck extends Duck {
	public ModelDuck() {
		flyBehavior = new FlyNoWay();
		quackBehavior = new Quack();
	}
	
	public void display() {
		System.out.println("저는 모형 오리 입니다.");
	}
}
```

### 3. FlyBehavior 형식의 클래스(FlyRocketPowered.java) 새로 생성

```java
public class FlyRocketPowered impolements FlyBehavior {
	public void fly {
		System.out.println("로켓 추진으로 날아갑니다");
	}
}
```

### 4. 테스트 클래스(MiniDuckSimulator.java)를 수정

> ModelDuck을 추가하고 로켓 진 기능을 부여

```java
public class MiniDuckSimulator {
	public static void main(String[] args) {
		Duck mallard = new MallardDuck;
		mallard.performQuck();
		mallard.performFly();
	}

	Duck model = new ModelDuck();
	model.performFly();
	model.setFlyBehovior(new FlwyRocketPowered());
	model.performFly(); // 상속받은 세터 메서드 호출
}
```

> 실행 중에 오리의 행동을 바꾸고 싶다면
>
> 원하는 행동에 해당하는 Duck의 세터 메서드를 호출하기

## 캡슐화된 행동 살펴보기

> 오리의 행동들을 일련의 행동으로 생각하는 것이 아닌
>
> 알고리즘군으로 생각하는 것
>
> 디자인에서 알고리즘은 오리가 하는 행동은(다른 방식으로 꽥꽥거리고 나는 행동)을 나타내지만
>
> 지역에 따라 달라지는 세금 계산 방식을 구현하는 클래스에서도 사용이 가능함

* [ ] A는 → B 이다.
* [ ] A에는 B가 있다.
* [ ] A가 B를 구현하는 관계이다.

> 행동을 나타내는 인터페이스 클래스
>
> * A에는 B가 있다.

## 두 클래스를 합치는 방법

> A에는 → B가 있다.

* 각 오리에는 나는 행동과 꽥꽥 거리느 행동을 위임
* 두 클래스를 합치는 것을 → 합성(composition)
* 올바른 행동 객체로 구성되어 행동을 부여받음
* 구성은 매우 중요한 테크닉

❄️ 유지보수나 확장보다 재사용에 더 많은 노력을 기울여야 하나요?

> 상속은 문제가 있으면 상속 이외에도 재사용을 이룰 수 있는 여러 다른 방법이 존재함

## 첫 번째 디자인 패턴: 전략 패턴

✅ 전략패턴 알고리즘군을 정의하고 → 캡슐화해서 각각의 알고리즘군을 수정해서 쓸 수 있게 해줌 \`사용 장점 클라이언트로부터 알고리즘을 분리해서 -> 독립적으로 변경\`
